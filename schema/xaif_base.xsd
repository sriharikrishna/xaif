<?xml version="1.0" encoding="UTF-8"?> 

<!-- *********************************************************** -->
<!-- XAIF Schema Definition (version 1.0)                        -->
<!-- Boyana Norris and Uwe Naumann                               -->
<!-- MCS, ANL, 2002/03                                           -->
<!-- *********************************************************** -->

<xsd:schema xmlns="http://www.mcs.anl.gov/XAIF"
	    xmlns:xsd="http://www.w3.org/2001/XMLSchema"
	    targetNamespace="http://www.mcs.anl.gov/XAIF"
	    xmlns:xaif_base="http://www.mcs.anl.gov/XAIF_BASE"
            version="xaif 1.0"
            elementFormDefault="qualified"
            attributeFormDefault="unqualified">       

<!-- *********************************************************** -->
<!-- Vertices -->
<!-- *********************************************************** -->

<xsd:complexType name="VertexType">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
	    VertexType is abstract base type for vertices in XAIF graphs.
	    Each vertex has a vertex_id that must be unique within the current
	    graph. Whenever the graph consists of a single vertex only the
	    vertex_id does not have to be specified and the default value
	    "1" is used.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:attribute name="vertex_id" type="xsd:positiveInteger" use="optional" default="1"/>
</xsd:complexType>

<!-- *********************************************************** -->
<!-- Edges -->
<!-- *********************************************************** -->

<xsd:complexType name="EdgeType">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
      EdgeType is abstract base type for edges in XAIF graphs.
      Its attributes comprise a locally unique edge_id, the source, and 
      the target. If only one edge is present, then the edge_id does not
      have to be specified and the default value "1" is used.
      Both source and target are vertex_id's of vertices in 
      the corresponding XAIF graph. 
    </xsd:documentation>
  </xsd:annotation>

  <xsd:attribute name="edge_id" type="xsd:positiveInteger" use="optional" default="1"/>
  <xsd:attribute name="source" type="xsd:positiveInteger" use="required"/>
  <xsd:attribute name="target" type="xsd:positiveInteger" use="required"/>
</xsd:complexType>

<!-- *********************************************************** -->
<!-- Symbols -->
<!-- *********************************************************** -->

<xsd:simpleType name="SymbolKindType">

  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  We distinguish between the following kinds of symbols:
		  1. "subroutine" - the name of a subroutine
		  2. "variable" - the name of a variable
    </xsd:documentation>
  </xsd:annotation>

  <xsd:restriction base="xsd:string">
    <xsd:enumeration value="subroutine"/>
    <xsd:enumeration value="variable"/>
  </xsd:restriction>
</xsd:simpleType>

<xsd:simpleType name="SymbolTypeType">

  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Symbol types as they appear in the declaration. "void" is
		  for subroutines / user-defined functions only.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:restriction base="xsd:string">
    <xsd:enumeration value="void"/>
    <xsd:enumeration value="real"/>
    <xsd:enumeration value="double"/>
    <xsd:enumeration value="integer"/>
    <xsd:enumeration value="bool"/>
    <xsd:enumeration value="char"/>
    <xsd:enumeration value="string"/>
  </xsd:restriction>
</xsd:simpleType>

<xsd:simpleType name="SymbolShapeType">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
	    The shape of a symbol. So far, we are dealing with scalar 
	    symbols only. When introducing vectors, matrices, and tensors
	    we intend to take a C-like approach, that is matrices are vectors
	    of vectors; three tensors are vectors of matrices, etc.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:restriction base="xsd:string">
    <xsd:enumeration value="scalar"/>
    <xsd:enumeration value="vector"/>
    <xsd:enumeration value="matrix"/>
    <xsd:enumeration value="three_tensor"/>
    <xsd:enumeration value="four_tensor"/>
  </xsd:restriction>

</xsd:simpleType>

<xsd:complexType name="SymbolType">
  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Symbols are stored in the symbol table. They are uniquely
		  identified within the current scope (the current symbol 
		  table) by their symbol_id. Furthermore, we store their
		  kind, type, and shape. By default, we consider real scalar
		  variables.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:attribute name="symbol_id"   type="xsd:string" use="required"/>
  <xsd:attribute name="kind"   type="SymbolKindType" default="variable"/>
  <xsd:attribute name="type"   type="SymbolTypeType" default="real"/>
  <xsd:attribute name="shape"   type="SymbolShapeType" default="scalar"/>
  <xsd:attribute name="frontend_tag" type="xsd:string" use="optional"/>
</xsd:complexType>

<!-- *********************************************************** -->
<!-- Symbol Table -->
<!-- *********************************************************** -->

<xsd:complexType name="SymbolTableType">
  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  The symbol table is a list of one or more symbols.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:sequence>
    <xsd:element name="Symbol" type="SymbolType" 
      minOccurs="1" maxOccurs="unbounded">
    </xsd:element>  
  </xsd:sequence>
</xsd:complexType>

<xsd:element name="SymbolTable" type="SymbolTableType">
  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  symbol_id's of symbols must be unique within the current
		  symbol table. SymbolReference's and FunctionCall's refer
		  to these symbol_id's.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:unique name="st_unique">
    <xsd:selector xpath="Symbol"/>
    <xsd:field xpath="@symbol_id"/>
  </xsd:unique>
  <xsd:key name="st_symbolId">
    <xsd:selector xpath="Symbol"/> 
    <xsd:field xpath="@symbol_id"/>
  </xsd:key>
  <xsd:keyref name="st_keyref1" refer="st_symbolId">
    <xsd:selector xpath="SymbolReference"/>
     <xsd:field xpath="@symbol_id"/>  
  </xsd:keyref>
</xsd:element>

<!-- *********************************************************** -->
<!-- Scope Hierarchy -->
<!-- *********************************************************** -->

<xsd:complexType name="ScopeHierarchyType">

  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  The scope hierarchy is a tree with a root representing
		  the global scope. The global scope usually contains
		  the name of the top-level routine, the names of its
		  arguments, and any global symbols. 
    </xsd:documentation>
  </xsd:annotation>

  <xsd:sequence>

    <xsd:element name="Scope" minOccurs="1" maxOccurs="unbounded">

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		Scopes are the vertices in the scope hierarchy. They
		are derived from the abstract base types VertexType.
		Scopes are identified uniquely by their vertex_id's.
		Each scope contains exactly one symbol table.
        </xsd:documentation>
      </xsd:annotation>

      <xsd:complexType>
        <xsd:complexContent>
          <xsd:extension base="VertexType">
            <xsd:sequence>
              <xsd:element ref="SymbolTable" 
    		   minOccurs="1" maxOccurs="1"/>
            </xsd:sequence>
          </xsd:extension>
        </xsd:complexContent>
      </xsd:complexType>
    </xsd:element>

    <xsd:element name="ScopeEdge" type="EdgeType" 
    		   minOccurs="0" maxOccurs="unbounded">

      <xsd:annotation>
	<xsd:documentation xml:lang="en">
          There is an edge connecting scope i with scope j if j is
	  contained in i. Scope edges do not have to be specified if the
	  containment information is not relevant. In this case the scope
	  hierarchy is a set of well-distinguishable scopes.
        </xsd:documentation>
      </xsd:annotation>

    </xsd:element>

  </xsd:sequence>

</xsd:complexType>

<xsd:element name="ScopeHierarchy" type="ScopeHierarchyType">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
	    The vertex_id's of single scopes must be unique within the scope 
	    hierarchy. Scopes are referenced via their vertex_id's.
	    Both the source and the target of a scope edge must be 
	    vertex_id's of scopes.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:unique name="scv_unique">
    <xsd:selector xpath="Scope"/><xsd:field xpath="@vertex_id"/>
  </xsd:unique>
  <xsd:unique name="sce_unique">
    <xsd:selector xpath="ScopeEdge"/><xsd:field xpath="@edge_id"/>
  </xsd:unique>
  <xsd:key name='sc_vertexId'>
    <xsd:selector xpath="Scope"/><xsd:field xpath="@vertex_id"/>
  </xsd:key>
  <xsd:keyref name="sc_keyref1" refer='sc_vertexId'>
    <xsd:selector xpath="ScopeEdge"/><xsd:field xpath="@source"/>  
  </xsd:keyref>
  <xsd:keyref name="sc_keyref2" refer='sc_vertexId'>
    <xsd:selector xpath="ScopeEdge"/><xsd:field xpath="@target"/>  
  </xsd:keyref>
  <xsd:keyref name="sc_keyref3" refer='sc_vertexId'>
    <xsd:selector xpath="SymbolReference"/><xsd:field xpath="@scope_id"/>  
  </xsd:keyref>

</xsd:element>  

<!-- *********************************************************** -->
<!-- Call Graph -->
<!-- *********************************************************** -->

<xsd:complexType name="TopLevelArgumentType">
  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  References to arguments of the top-level routine. 
		  An argument is uniquely specified by its position
		  within the argument list. 
    </xsd:documentation>
  </xsd:annotation>

  <xsd:sequence>
  <xsd:element name="ArgumentReference" minOccurs="1" maxOccurs="unbounded">
    <xsd:complexType>
      <xsd:attribute name="argument" type="xsd:positiveInteger"/>
    </xsd:complexType>
  </xsd:element>
  </xsd:sequence>
</xsd:complexType>

<xsd:complexType name="CallGraphType">

  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  The call graph is the root element of any XAIF file.
		  It contains the scope hierarchy, lists of independent
		  and dependent variables, call graph vertices and edges.
		  The name of the top-level routine must be specified. 
		  Optionally, a program_name can be assigned.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:sequence>

    <xsd:element ref="ScopeHierarchy" minOccurs="1" maxOccurs="1">

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          The scope hierarchy is always attached to the call graph.
        </xsd:documentation>
      </xsd:annotation>

    </xsd:element> 

    <xsd:element name="IndependentVariables" type="TopLevelArgumentType" 
	    minOccurs="0" maxOccurs="unbounded">
      <xsd:annotation>
	      <xsd:documentation xml:lang="en">
		      Derivatives are always computed for arguments of
		      the top-level routines (the dependent variables) 
		      with respect to other arguments of the top-level 
		      routine (the independent variables).
        </xsd:documentation>
      </xsd:annotation>

    </xsd:element> 
    <xsd:element name="DependentVariables" type="TopLevelArgumentType" 
      minOccurs="0" maxOccurs="unbounded"/>

    <xsd:element ref="CallGraphVertex"     
    		   minOccurs="1" maxOccurs="unbounded">

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		Call graph vertices are abstract base types for
		control flow graphs that represent the subroutines 
		in the program.
        </xsd:documentation>
      </xsd:annotation>

    </xsd:element>

    <xsd:element name="CallGraphEdge" type="EdgeType" 
    		   minOccurs="0" maxOccurs="unbounded">

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          An edge connects two call graph vertices if the target is
          called within the source.
        </xsd:documentation>
      </xsd:annotation>

    </xsd:element>

  </xsd:sequence>

  <xsd:attribute name="program_name" type="xsd:string" use="optional"/>
  <xsd:attribute name="toplevel_routine_name" type="xsd:string" use="required"/>

</xsd:complexType>

<xsd:element name="CallGraph" type="CallGraphType">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
      The vertex_id's of vertices must be unique within the call graph.
      Call graph vertices are referenced via their vertex_id's.
      Both the source and the target of a call graph edge must be vertex_id's.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:unique name="cgv_unique">
    <xsd:selector xpath="ControlFlowGraph"/><xsd:field xpath="@vertex_id"/>
  </xsd:unique>
  <xsd:unique name="cge_unique">
    <xsd:selector xpath="CallGraphEdge"/><xsd:field xpath="@edge_id"/>
  </xsd:unique>
  <xsd:key name='cg_vertexId'>
	  <xsd:selector xpath="ControlFlowGraph"/><xsd:field xpath="@vertex_id"/>
  </xsd:key>
  <xsd:keyref name="cg_keyref1" refer='cg_vertexId'>
    <xsd:selector xpath="CallGraphEdge"/><xsd:field xpath="@source"/>  
  </xsd:keyref>
  <xsd:keyref name="cg_keyref2" refer='cg_vertexId'>
    <xsd:selector xpath="CallGraphEdge"/><xsd:field xpath="@target"/>  
  </xsd:keyref>

</xsd:element>  

<xsd:element name="CallGraphVertex" type="VertexType">
  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Call graph vertices are declared as abstract types, that
		  is elements of this type will never appear in the XAIF
		  file. Elements that are based on CallGraphVertex as
		  a substitution group (for example, ControlFlowGraph) are
		  used instead.
    </xsd:documentation>
  </xsd:annotation>
</xsd:element>  

<!-- *********************************************************** -->
<!-- Control Flow Graph -->
<!-- *********************************************************** -->

<xsd:simpleType name="IntentType">

  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  The intent of subroutine arguments.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:restriction base="xsd:string">
    <xsd:enumeration value="in"/>
    <xsd:enumeration value="out"/>
    <xsd:enumeration value="inout"/>
  </xsd:restriction>
</xsd:simpleType>

<xsd:complexType name="ArgumentSymbolReferenceType">

  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Arguments of subroutines are uniquely determined by their
		  position within the argument list and by a reference to the
		  corresponding symbol. Additionally, their activity status 
		  (default: active) and intent (default: inout) can be specified.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:attribute name="position" type="xsd:positiveInteger" use="required"/>
  <xsd:attribute name="symbol_id" type="xsd:string" use="required"/>
  <xsd:attribute name="scope_id" type="xsd:positiveInteger" use="required"/>
  <xsd:attribute name="active" type="xsd:boolean" use="optional" default="true"/>
  <xsd:attribute name="intent" type="IntentType" use="optional" default="inout"/>
</xsd:complexType>

<xsd:complexType name="ControlFlowGraphType">
 <xsd:complexContent>
    <xsd:extension base="VertexType">       

  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Subroutines are represented by control flow graphs.
		  A control flow graph contains an argument list vertices 
		  and edges. Furthermore, the name of the corresponding
		  subroutine must be specified.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:sequence>

    <xsd:element name="ArgumentList" minOccurs="0" maxOccurs="1">
      <xsd:complexType>
        <xsd:sequence>

          <xsd:annotation>
            <xsd:documentation xml:lang="en">
              The argument list.
            </xsd:documentation>
          </xsd:annotation>
      
          <xsd:element name="ArgumentSymbolReference" type="ArgumentSymbolReferenceType"
    		   minOccurs="1" maxOccurs="unbounded"/>

        </xsd:sequence>
      </xsd:complexType>
    </xsd:element>

    <xsd:element ref="ControlFlowVertex" 
    		   minOccurs="1" maxOccurs="unbounded">

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		Control flow graph vertices represent the basic 
		blocks or certain control flow statements contained 
		within a subroutine. 
        </xsd:documentation>
      </xsd:annotation>

    </xsd:element>

    <xsd:element name="ControlFlowEdge" type="EdgeType" 
    		   minOccurs="0" maxOccurs="unbounded">

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Control flow graph edges represent the flow of control within the
	  corresponding subroutine. An edge connects two control flow graph 
	  vertex substitutes i and j if there are values for the subroutine 
	  arguments such that j is executed immediately after i.
        </xsd:documentation>
      </xsd:annotation>

    </xsd:element>

  </xsd:sequence>
  <xsd:attribute name="subroutine_name" type="xsd:string" use="required"/>
  
    </xsd:extension>
  </xsd:complexContent>   
</xsd:complexType>

<xsd:element name="ControlFlowGraph" type="ControlFlowGraphType"
	substitutionGroup="CallGraphVertex">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
	    The vertex_id's of control flow graph vertex substitutes must be unique with
	    the current control flow graph. The corresponding elements are referenced via 
	    their vertex_id's.  Both the source and the target of an edge must be 
	    vertex_id's.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:unique name="cfgv_unique">
	  <xsd:selector xpath="BasicBlock|Entry|Exit|If|ForLoop|PreLoop|PostLoop"/>
      <xsd:field xpath="@vertex_id"/>
  </xsd:unique>
  <xsd:unique name="cfge_unique">
    <xsd:selector xpath="ControlFlowEdge"/><xsd:field xpath="@edge_id"/>
  </xsd:unique>
  <xsd:key name='cfg_vertexId'>
	  <xsd:selector xpath="BasicBlock|Entry|Exit|If|ForLoop|PreLoop|PostLoop"/>
      <xsd:field xpath="@vertex_id"/>
  </xsd:key>
  <xsd:keyref name="cfg_keyref1" refer='cfg_vertexId'>
    <xsd:selector xpath="ControlFlowEdge"/><xsd:field xpath="@source"/>  
  </xsd:keyref>
  <xsd:keyref name="cfg_keyref2" refer='cfg_vertexId'>
    <xsd:selector xpath="ControlFlowEdge"/><xsd:field xpath="@target"/>  
  </xsd:keyref>

</xsd:element> 

<xsd:element name="ControlFlowVertex" type="VertexType">
  <xsd:annotation>
    <xsd:documentation xml:lang="en">
	Control flow graph vertices are abstract. Substitutes are used within the
	XAIF file.
    </xsd:documentation>
  </xsd:annotation>
</xsd:element> 

<!-- *********************************************************** -->
<!-- Basic Block -->
<!-- *********************************************************** -->

<xsd:complexType name="BasicBlockType">
  <xsd:complexContent>
    <xsd:extension base="VertexType">    

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		Basic blocks are sequences of assignments and subroutine calls.
        </xsd:documentation>
      </xsd:annotation>

      <xsd:sequence>
	<xsd:choice minOccurs="1" maxOccurs="unbounded">
          <xsd:element ref="Assignment"/>
          <xsd:element ref="SubroutineCall"/>
        </xsd:choice>
      </xsd:sequence>

    </xsd:extension>
  </xsd:complexContent>   
</xsd:complexType>

<xsd:element name="BasicBlock" type="BasicBlockType"
	substitutionGroup="ControlFlowVertex">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		Basic blocks are substitutes for control flow vertices.
		Single statements within basic blocks must have a unique
		statement_id.
        </xsd:documentation>
      </xsd:annotation>
  <xsd:unique name="statement_unique">
    <xsd:selector xpath="Assignment | SubroutineCall"/>
     <xsd:field xpath="@statement_id"/>
  </xsd:unique>
</xsd:element>

<!-- *********************************************************** -->
<!-- ForLoop -->
<!-- *********************************************************** -->

<xsd:complexType name="ForLoopType">
  <xsd:complexContent>
    <xsd:extension base="VertexType">    

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          For loops with a single initialization, condition, and update.
        </xsd:documentation>
      </xsd:annotation>

      <xsd:sequence>
         <xsd:element name="Initialization" type="AssignmentType"
		   minOccurs="0" maxOccurs="1"/>
         <xsd:element name="Condition" type="ExpressionType"
		   minOccurs="0" maxOccurs="1"/>
         <xsd:element name="Update" type="AssignmentType"
		   minOccurs="0" maxOccurs="1"/>
      </xsd:sequence>

      <xsd:attribute name="frontend_tag" type="xsd:string" use="optional"/>
    </xsd:extension>
  </xsd:complexContent>   
</xsd:complexType>

<xsd:element name="ForLoop" type="ForLoopType"
	substitutionGroup="ControlFlowVertex">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		Forloops are substitutes for control flow vertices.
        </xsd:documentation>
      </xsd:annotation>
</xsd:element>

<!-- *********************************************************** -->
<!-- PreLoop -->
<!-- *********************************************************** -->

<xsd:complexType name="PreLoopType">
  <xsd:complexContent>
    <xsd:extension base="VertexType">    

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Loops with test of condition before first execution of loop body.
        </xsd:documentation>
      </xsd:annotation>

      <xsd:sequence>
         <xsd:element name="Condition" type="ExpressionType"
   		   minOccurs="0" maxOccurs="1"/>
      </xsd:sequence>
    </xsd:extension>
  </xsd:complexContent>   
</xsd:complexType>

<xsd:element name="PreLoop" type="PreLoopType"
	substitutionGroup="ControlFlowVertex">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		Preloops are substitutes for control flow vertices.
        </xsd:documentation>
      </xsd:annotation>
</xsd:element>

<!-- *********************************************************** -->
<!-- PostLoop -->
<!-- *********************************************************** -->

<xsd:complexType name="PostLoopType">
  <xsd:complexContent>
    <xsd:extension base="VertexType">    

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Loops with test of condition after first execution of loop body.
        </xsd:documentation>
      </xsd:annotation>

      <xsd:sequence>
         <xsd:element name="Condition" type="ExpressionType"
		   minOccurs="0" maxOccurs="1"/>
      </xsd:sequence>
    </xsd:extension>
  </xsd:complexContent>   
</xsd:complexType>

<xsd:element name="PostLoop" type="PostLoopType"
	substitutionGroup="ControlFlowVertex">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		Postloops are substitutes for control flow vertices.
        </xsd:documentation>
      </xsd:annotation>
</xsd:element>

<!-- *********************************************************** -->
<!-- If -->
<!-- *********************************************************** -->

<xsd:complexType name="IfType">
  <xsd:complexContent>
    <xsd:extension base="VertexType">    

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          If tests in control flow graph.
        </xsd:documentation>
      </xsd:annotation>

      <xsd:sequence>
         <xsd:element name="Condition" type="ExpressionType"
		   minOccurs="0" maxOccurs="1"/>
      </xsd:sequence>
    </xsd:extension>
  </xsd:complexContent>   
</xsd:complexType>

<xsd:element name="If" type="IfType"
	substitutionGroup="ControlFlowVertex">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		If's are substitutes for control flow vertices.
        </xsd:documentation>
      </xsd:annotation>
</xsd:element>

<!-- *********************************************************** -->
<!-- Entry -->
<!-- *********************************************************** -->

<xsd:complexType name="EntryType">
  <xsd:complexContent>
    <xsd:extension base="VertexType">    

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Unique entry node of control flow graph.
        </xsd:documentation>
      </xsd:annotation>
      
    </xsd:extension>
  </xsd:complexContent>   
</xsd:complexType>

<xsd:element name="Entry" type="EntryType"
	substitutionGroup="ControlFlowVertex">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		Entry is a substitute for a control flow vertex.
        </xsd:documentation>
      </xsd:annotation>
</xsd:element>

<!-- *********************************************************** -->
<!-- Exit -->
<!-- *********************************************************** -->

<xsd:complexType name="ExitType">
  <xsd:complexContent>
    <xsd:extension base="VertexType">    

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
          Unique exit node in control flow graph.
        </xsd:documentation>
      </xsd:annotation>
    </xsd:extension>
  </xsd:complexContent>   
</xsd:complexType>

<xsd:element name="Exit" type="ExitType"
	substitutionGroup="ControlFlowVertex">
      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		Exit is a substitute for a control flow vertex.
        </xsd:documentation>
      </xsd:annotation>
</xsd:element>

<!-- *********************************************************** -->
<!-- Assignment -->
<!-- *********************************************************** -->

<xsd:complexType name="AssignmentType">
  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Assignments consist of a variable reference on the lhs
		  and an expression on the rhs. Within the current basic
		  block they are uniquely identified by their statement_id.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:sequence>

    <xsd:element name="AssignmentLHS" type="VariableReferenceType"
                  minOccurs="1" maxOccurs="1">
      <xsd:unique name="lhsv_unique">
        <xsd:selector xpath="SymbolReference"/>
         <xsd:field xpath="@vertex_id"/>
      </xsd:unique>
      <xsd:unique name="lhse_unique">
        <xsd:selector xpath="VariableReferenceEdge"/>
         <xsd:field xpath="@edge_id"/>
      </xsd:unique>
      <xsd:key name='lhs_vertexId'>
        <xsd:selector xpath="SymbolReference"/>
        <xsd:field xpath="@vertex_id"/>
      </xsd:key>
      <xsd:keyref name="lhs_keyref1" refer='lhs_vertexId'>
        <xsd:selector xpath="VariableReferenceEdge"/>
        <xsd:field xpath="@source"/>  
      </xsd:keyref>
      <xsd:keyref name="lhs_keyref2" refer='lhs_vertexId'>
        <xsd:selector xpath="VariableReferenceEdge"/>
        <xsd:field xpath="@target"/>  
      </xsd:keyref>
    </xsd:element>

    <xsd:element name="AssignmentRHS" type="ExpressionType" 
                  minOccurs="1" maxOccurs="1">
      <xsd:unique name="rhsv_unique">
        <xsd:selector xpath="VariableReference|Constant|Intrinsic|FunctionCall|BooleanOperation"/>
         <xsd:field xpath="@vertex_id"/>
      </xsd:unique>
      <xsd:unique name="rhse_unique">
        <xsd:selector xpath="ExpressionEdge"/><xsd:field xpath="@edge_id"/>
      </xsd:unique>
      <xsd:key name='rhs_vertexId'>
        	  <xsd:selector xpath="VariableReference|Constant|Intrinsic|FunctionCall|BooleanOperation"/> 
        <xsd:field xpath="@vertex_id"/>
      </xsd:key>
      <xsd:keyref name="rhs_keyref1" refer='rhs_vertexId'>
        <xsd:selector xpath="ExpressionEdge"/>
        <xsd:field xpath="@source"/>  
      </xsd:keyref>
      <xsd:keyref name="rhs_keyref2" refer='rhs_vertexId'>
        <xsd:selector xpath="ExpressionEdge"/>
        <xsd:field xpath="@target"/>  
      </xsd:keyref>
    </xsd:element>

  </xsd:sequence>
  <xsd:attribute name="statement_id" type="xsd:string" use="required"/>
</xsd:complexType>

<xsd:element name="Assignment" type="AssignmentType"></xsd:element>        

<!-- *********************************************************** -->
<!-- Expression -->
<!-- *********************************************************** -->

<xsd:complexType name="ExpressionEdgeType">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
    </xsd:documentation>
  </xsd:annotation>
  <xsd:complexContent>
    <xsd:extension base="EdgeType">
      <xsd:attribute name="position" type="xsd:positiveInteger" use="required"/>
    </xsd:extension>
  </xsd:complexContent>               

</xsd:complexType>

<xsd:complexType name="ExpressionType">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
      Expressions are dag's in the classical compiler sense.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:sequence>

    <xsd:element ref="ExpressionVertex" 
			minOccurs="1" maxOccurs="unbounded">

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		Expression vertices are abstract placeholders for a variety
		of substitutes (see below).
        </xsd:documentation>
      </xsd:annotation>

    </xsd:element>

    <xsd:element name="ExpressionEdge" type="ExpressionEdgeType" 
			minOccurs="0" maxOccurs="unbounded">

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		Two expression vertices are connected by an expression edge if 
		the result of the subdag induced by the source is an argument of 
		the operation represented by the target. 
		Leafs are always variable references or constants. 
        </xsd:documentation>
      </xsd:annotation>

    </xsd:element>

  </xsd:sequence>
</xsd:complexType>

<xsd:element name="Expression" type="ExpressionType">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
	    The vertex_id's of all expression vertex substitutes must be unique within the
	    current expression. Substitutes for expression vertices are
	    elements of type VariableReference, Constant, Intrinsic, FunctionCall, 
	    BooleanOperation.
	    Edges reference the respective source and target by
	    their vertex_id's.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:unique name="egv_unique">
    <xsd:selector xpath="VariableReference|Constant|Intrinsic|FunctionCall|BooleanOperation"/>
     <xsd:field xpath="@vertex_id"/>
  </xsd:unique>
  <xsd:unique name="ege_unique">
    <xsd:selector xpath="ExpressionEdge"/><xsd:field xpath="@edge_id"/>
  </xsd:unique>
  <xsd:key name='eg_vertexId'>
	  <xsd:selector xpath="VariableReference|Constant|Intrinsic|FunctionCall|BooleanOperation"/> 
    <xsd:field xpath="@vertex_id"/>
  </xsd:key>
  <xsd:keyref name="eg_keyref1" refer='eg_vertexId'>
    <xsd:selector xpath="ExpressionEdge"/>
    <xsd:field xpath="@source"/>  
  </xsd:keyref>
  <xsd:keyref name="eg_keyref2" refer='eg_vertexId'>
    <xsd:selector xpath="ExpressionEdge"/>
    <xsd:field xpath="@target"/>  
  </xsd:keyref>
</xsd:element>     

<xsd:element name="ExpressionVertex" type="VertexType">
  <xsd:annotation>
    <xsd:documentation xml:lang="en">
	Expression vertices are abstract. Substitutes are used within the
	XAIF file.
    </xsd:documentation>
  </xsd:annotation>
</xsd:element> 

<!-- *********************************************************** -->
<!-- Subroutine Call -->
<!-- *********************************************************** -->

<xsd:complexType name="SubroutineCallArgumentType">

  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Arguments of subroutine calls are expressions appearing
		  in a certain position within the argument list.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:complexContent>
    <xsd:extension base="ExpressionType">
      <xsd:attribute name="position" type="xsd:positiveInteger" use="required"/>
    </xsd:extension>
  </xsd:complexContent>               

</xsd:complexType>


<xsd:complexType name="SubroutineCallType">
  <xsd:annotation>
    <xsd:documentation xml:lang="en">
	    Subroutine calls appear in basic blocks together with assignments. 
	    They are equivalent to void functions in C/C++ or explicitly CALLed 
	    subroutines in Fortran. They may have  arguments in the form of 
	    expressions. The subroutine call is identified uniquely by the statement_id
	    within the current basic block, the symbol_id of its name within the 
	    corresponding symbol table.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:sequence>
    <xsd:element name="Argument" type="SubroutineCallArgumentType" 
      minOccurs="0" maxOccurs="unbounded"/>
  </xsd:sequence>
  <xsd:attribute name="statement_id" type="xsd:string" use="required"/>
  <xsd:attribute name="symbol_id" type="xsd:string"/>
  <xsd:attribute name="scope_id" type="xsd:positiveInteger"/>
</xsd:complexType> 

<xsd:element name="SubroutineCall" type="SubroutineCallType"/>

<!-- *********************************************************** -->
<!-- Variable Reference -->
<!-- *********************************************************** -->

<xsd:complexType name="VariableReferenceType">
  <xsd:complexContent>
    <xsd:extension base="VertexType">

      <xsd:annotation>
        <xsd:documentation xml:lang="en">
		Variable references are special expressions. For the time being,
		the only vertex type allowed are symbol references. This will be
		extended to comprise array access operators. The corresponding
		index expressions will become elements of the array access operator
		itself.
        </xsd:documentation>
      </xsd:annotation>

      <xsd:sequence>

        <xsd:element ref="VariableReferenceVertex" 
    			minOccurs="1" maxOccurs="unbounded">

          <xsd:annotation>
		  <xsd:documentation xml:lang="en">
			  Variable reference vertices are abstract placeholders
			  for symbol references and array references (later).
            </xsd:documentation>
          </xsd:annotation>

        </xsd:element>

        <xsd:element name="VariableReferenceEdge" type="EdgeType" 
    			minOccurs="0" maxOccurs="unbounded">

          <xsd:annotation>
		  <xsd:documentation xml:lang="en"> 
			  Not used so far. Later used to access array elements.
            </xsd:documentation>
          </xsd:annotation>

        </xsd:element>

      </xsd:sequence>

    </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="VariableReference" type="VariableReferenceType"
	     substitutionGroup="ExpressionVertex">

  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Variable references appear inside of expressions. Both vertex and
		  edge id's must be unique inside a variable reference. Edges reference
		  vertex_id's for source and target.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:unique name="vrv_unique">
    <xsd:selector xpath="SymbolReference"/>
     <xsd:field xpath="@vertex_id"/>
  </xsd:unique>
  <xsd:unique name="vre_unique">
    <xsd:selector xpath="VariableReferenceEdge"/>
     <xsd:field xpath="@edge_id"/>
  </xsd:unique>
  <xsd:key name='vr_vertexId'>
    <xsd:selector xpath="SymbolReference"/>
    <xsd:field xpath="@vertex_id"/>
  </xsd:key>
  <xsd:keyref name="vr_keyref1" refer='vr_vertexId'>
    <xsd:selector xpath="VariableReferenceEdge"/>
    <xsd:field xpath="@source"/>  
  </xsd:keyref>
  <xsd:keyref name="vr_keyref2" refer='vr_vertexId'>
    <xsd:selector xpath="VariableReferenceEdge"/>
    <xsd:field xpath="@target"/>  
  </xsd:keyref>
</xsd:element>     

<xsd:element name="VariableReferenceVertex" type="VertexType" abstract="true">
  <xsd:annotation>
    <xsd:documentation xml:lang="en">
	Variable reference vertices are abstract.  
	Substitutes are used within the XAIF file.
    </xsd:documentation>
  </xsd:annotation>
</xsd:element> 

<!-- *********************************************************** -->
<!-- Built-in operations. -->
<!-- *********************************************************** -->

<xsd:simpleType name="BuiltinRealOperations">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
	    Real operations built into XAIF. "add_scal_scal" and "mul_scal_scal" 
	    are reserved names to be used in Jacobian codes. 
    </xsd:documentation>
  </xsd:annotation>

  <xsd:restriction base="xsd:string">
    <xsd:enumeration value="add_scal_scal"/>
    <xsd:enumeration value="mul_scal_scal"/>
  </xsd:restriction>
</xsd:simpleType>

<xsd:simpleType name="BuiltinBooleanOperations">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
      Boolean operations built into XAIF.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:restriction base="xsd:string">
    <xsd:enumeration value="less_than"/>
    <xsd:enumeration value="less_or_equal"/>
    <xsd:enumeration value="greater_than"/>
    <xsd:enumeration value="greater_or_equal"/>
    <xsd:enumeration value="equal"/>
    <xsd:enumeration value="not_equal"/>
  </xsd:restriction>
</xsd:simpleType>

<xsd:simpleType name="BuiltinLogicalOperations">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
      Logical operations built into XAIF.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:restriction base="xsd:string">
    <xsd:enumeration value="and"/>
    <xsd:enumeration value="or"/>
    <xsd:enumeration value="not"/>
    <xsd:enumeration value="xor"/>
  </xsd:restriction>
</xsd:simpleType>

<!-- *********************************************************** -->
<!-- Intrinsics. 
     An intrinsic is any function that we have derivative code
     for. We distinguish between inlinable a non-inlinable
     intrinsics. The latter are specified in a different file. -->
<!-- *********************************************************** -->

<xsd:simpleType name="IntrinsicTypeName">

  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Intrinsics are either inlinable or not. If inlinable then the code
		  for the local partial derivatives can be looked up in a separate
		  XML file (see xaif_inlinable_intrinsics.xsd). If they are not
		  inlinable, then some precompiled derivative routine is called, whose
		  name and partial derivative signature is given in a separate XML file
		  (see xaif_noninlinable_intrinsics.xsd).
    </xsd:documentation>
  </xsd:annotation>

  <xsd:restriction base="xsd:string">
    <xsd:enumeration value="inlinable"/>
    <xsd:enumeration value="non-inlinable"/>
  </xsd:restriction>
</xsd:simpleType>

<xsd:complexType name="IntrinsicType">

  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Operations are intrinsic if derivative code is available for them.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:complexContent>
    <xsd:extension base="VertexType">
      <xsd:attribute name="name" type="xsd:string" use="required"/>
      <xsd:attribute name="type" type="xsd:string" use="optional" default="inlinable"/>
    </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="Intrinsic" type="IntrinsicType" 
	substitutionGroup="ExpressionVertex">
  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Intrinsics appear inside expressions as substitutes for
		  expression vertices.
    </xsd:documentation>
  </xsd:annotation>
</xsd:element>


<!-- *********************************************************** -->
<!-- Boolean operations -->
<!-- *********************************************************** -->

<xsd:complexType name="BooleanOperationType">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
      Boolean operations that are built into XAIF.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:complexContent>
    <xsd:extension base="VertexType">
      <xsd:attribute name="name" type="BuiltinBooleanOperations" use="required"/>
    </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="BooleanOperation" type="BooleanOperationType" 
	     substitutionGroup="ExpressionVertex">
  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Boolean operations appear inside expressions as substitutes for
		  expression vertices.
    </xsd:documentation>
  </xsd:annotation>
</xsd:element>


<!-- *********************************************************** -->
<!-- Symbol Reference -->
<!-- *********************************************************** -->

<xsd:complexType name="SymbolReferenceType">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
      A symbol is referenced uniquely by its id inside a given scope.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:complexContent>
    <xsd:extension base="VertexType">
      <xsd:attribute name="symbol_id" type="xsd:string" use="required"/>
      <xsd:attribute name="scope_id" type="xsd:positiveInteger" use="required"/>
    </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="SymbolReference" type="SymbolReferenceType" 
	     substitutionGroup="VariableReferenceVertex">
  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Symbol references appear inside variable references as substitutes for
		  variable reference vertices.
    </xsd:documentation>
  </xsd:annotation>

</xsd:element>

<!-- *********************************************************** -->
<!-- Array Element Reference -->
<!-- *********************************************************** -->

<xsd:complexType name="ArrayElementReferenceType">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
      
    </xsd:documentation>
  </xsd:annotation>

  <xsd:complexContent>
    <xsd:extension base="VertexType">
      <xsd:sequence>
        <xsd:element name="Index" type="ExpressionType" 
        	minOccurs="1" maxOccurs="unbounded">

          <xsd:annotation>
            <xsd:documentation xml:lang="en"> 
            </xsd:documentation>
          </xsd:annotation>

        </xsd:element>
      </xsd:sequence>
    </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="ArrayElementReference" type="ArrayElementReferenceType" 
	substitutionGroup="VariableReferenceVertex">
  <xsd:annotation>
    <xsd:documentation xml:lang="en">
    </xsd:documentation>
  </xsd:annotation>

</xsd:element>

<!-- *********************************************************** -->
<!-- Constant -->
<!-- *********************************************************** -->

<xsd:simpleType name="ConstantTypeType">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
      Types of constants known in XAIF.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:restriction base="xsd:string">
    <xsd:enumeration value="real"/>
    <xsd:enumeration value="double"/>
    <xsd:enumeration value="integer"/>
    <xsd:enumeration value="bool"/>
    <xsd:enumeration value="char"/>
    <xsd:enumeration value="string"/>
  </xsd:restriction>
</xsd:simpleType>

<xsd:complexType name="ConstantType">

  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Constants in XAIF.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:complexContent>
    <xsd:extension base="VertexType">
      <xsd:attribute name="type" type="ConstantTypeType" use="required"/>
      <xsd:attribute name="value" type="xsd:string" use="required"/>
    </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="Constant" type="ConstantType" 
	     substitutionGroup="ExpressionVertex">
  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Constants appear inside expressions as substitutes for
		  expression vertices.
    </xsd:documentation>
  </xsd:annotation>
</xsd:element>

<!-- *********************************************************** -->
<!-- Function Call -->
<!-- *********************************************************** -->

<xsd:complexType name="FunctionCallType">

  <xsd:annotation>
    <xsd:documentation xml:lang="en">
	    Function calls are calls to subroutines (call graph vertices) that
	    have a non-void return type. They are not intrinsics since derivative
	    code must be generated by the AD tool. A function call is identified 
	    uniquely by its position within the expression (vertex_id of underlying
	    expression vertex), and the symbol that represents its name.
    </xsd:documentation>
  </xsd:annotation>

  <xsd:complexContent>
    <xsd:extension base="VertexType">
      <xsd:attribute name="symbol_id" type="xsd:string"/>
      <xsd:attribute name="scope_id" type="xsd:positiveInteger"/>
    </xsd:extension>
  </xsd:complexContent>
</xsd:complexType>

<xsd:element name="FunctionCall" type="FunctionCallType" 
	     substitutionGroup="ExpressionVertex">
  <xsd:annotation>
	  <xsd:documentation xml:lang="en">
		  Function calls appear inside expressions as substitutes for
		  expression vertices.
    </xsd:documentation>
  </xsd:annotation>
  <xsd:keyref name="st_keyref2" refer='st_symbolId'>
    <xsd:selector xpath="FunctionCall"/>
     <xsd:field xpath="@symbol_id"/>  
  </xsd:keyref>
</xsd:element>

</xsd:schema>
