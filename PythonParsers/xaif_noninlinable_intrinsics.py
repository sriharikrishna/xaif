#!/usr/bin/env python
# -*- coding: utf-8 -*- 

#
# Generated Wed Mar  7 09:10:09 2012 by generateDS.py version 2.7b.
#

import sys
import getopt
import re as re_

etree_ = None
Verbose_import_ = False
(   XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
    ) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError("Failed to import ElementTree from any known place")

def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
        'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    fvalue = float(value)
                except (TypeError, ValueError), exp:
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(node, 'Requires sequence of booleans ("true", "1", "false", "0")')
            return input_data
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#

def showIndent(outfile, level):
    for idx in range(level):
        outfile.write('    ')

def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1

def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1

def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1

def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text

def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass

def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip(): 
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace,name)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (self.name, self.value, self.name))
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s", "%s"),\n' % \
                (self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write('model_.MixedContainer(%d, %d, "%s",\n' % \
                (self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container

def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#

class NonInlinableIntrinsicBaseType(GeneratedsSuper):
    """base for representation of noninlinable intrinsics the name of the
    noninlable intrinsic is it non smooth?"""
    subclass = None
    superclass = None
    def __init__(self, nonSmooth=False, name=None, extensiontype_=None):
        self.nonSmooth = _cast(bool, nonSmooth)
        self.name = _cast(None, name)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if NonInlinableIntrinsicBaseType.subclass:
            return NonInlinableIntrinsicBaseType.subclass(*args_, **kwargs_)
        else:
            return NonInlinableIntrinsicBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_nonSmooth(self): return self.nonSmooth
    def set_nonSmooth(self, nonSmooth): self.nonSmooth = nonSmooth
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xaifnii:', name_='NonInlinableIntrinsicBaseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonInlinableIntrinsicBaseType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='NonInlinableIntrinsicBaseType'):
        if self.nonSmooth is not None and 'nonSmooth' not in already_processed:
            already_processed.append('nonSmooth')
            outfile.write(' nonSmooth="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.nonSmooth)), input_name='nonSmooth'))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='NonInlinableIntrinsicBaseType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NonInlinableIntrinsicBaseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.nonSmooth is not None and 'nonSmooth' not in already_processed:
            already_processed.append('nonSmooth')
            showIndent(outfile, level)
            outfile.write('nonSmooth = %s,\n' % (self.nonSmooth,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('nonSmooth', node)
        if value is not None and 'nonSmooth' not in already_processed:
            already_processed.append('nonSmooth')
            if value in ('true', '1'):
                self.nonSmooth = True
            elif value in ('false', '0'):
                self.nonSmooth = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NonInlinableIntrinsicBaseType


class ExplicitJacobianType(NonInlinableIntrinsicBaseType):
    subclass = None
    superclass = NonInlinableIntrinsicBaseType
    def __init__(self, nonSmooth=False, name=None, return_type='real', jacobian=None, Partial=None):
        super(ExplicitJacobianType, self).__init__(nonSmooth, name, )
        self.return_type = _cast(None, return_type)
        self.jacobian = _cast(None, jacobian)
        if Partial is None:
            self.Partial = []
        else:
            self.Partial = Partial
    def factory(*args_, **kwargs_):
        if ExplicitJacobianType.subclass:
            return ExplicitJacobianType.subclass(*args_, **kwargs_)
        else:
            return ExplicitJacobianType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Partial(self): return self.Partial
    def set_Partial(self, Partial): self.Partial = Partial
    def add_Partial(self, value): self.Partial.append(value)
    def insert_Partial(self, index, value): self.Partial[index] = value
    def get_return_type(self): return self.return_type
    def set_return_type(self, return_type): self.return_type = return_type
    def get_jacobian(self): return self.jacobian
    def set_jacobian(self, jacobian): self.jacobian = jacobian
    def export(self, outfile, level, namespace_='xaifnii:', name_='ExplicitJacobianType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExplicitJacobianType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ExplicitJacobianType'):
        super(ExplicitJacobianType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExplicitJacobianType')
        if self.return_type is not None and 'return_type' not in already_processed:
            already_processed.append('return_type')
            outfile.write(' return_type=%s' % (quote_attrib(self.return_type), ))
        if self.jacobian is not None and 'jacobian' not in already_processed:
            already_processed.append('jacobian')
            outfile.write(' jacobian=%s' % (self.gds_format_string(quote_attrib(self.jacobian).encode(ExternalEncoding), input_name='jacobian'), ))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ExplicitJacobianType', fromsubclass_=False):
        super(ExplicitJacobianType, self).exportChildren(outfile, level, namespace_, name_, True)
        for Partial_ in self.Partial:
            Partial_.export(outfile, level, namespace_, name_='Partial')
    def hasContent_(self):
        if (
            self.Partial or
            super(ExplicitJacobianType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExplicitJacobianType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.return_type is not None and 'return_type' not in already_processed:
            already_processed.append('return_type')
            showIndent(outfile, level)
            outfile.write('return_type = %s,\n' % (self.return_type,))
        if self.jacobian is not None and 'jacobian' not in already_processed:
            already_processed.append('jacobian')
            showIndent(outfile, level)
            outfile.write('jacobian = "%s",\n' % (self.jacobian,))
        super(ExplicitJacobianType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ExplicitJacobianType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Partial=[\n')
        level += 1
        for Partial_ in self.Partial:
            showIndent(outfile, level)
            outfile.write('model_.PartialType(\n')
            Partial_.exportLiteral(outfile, level, name_='PartialType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('return_type', node)
        if value is not None and 'return_type' not in already_processed:
            already_processed.append('return_type')
            self.return_type = value
        value = find_attr_value_('jacobian', node)
        if value is not None and 'jacobian' not in already_processed:
            already_processed.append('jacobian')
            self.jacobian = value
        super(ExplicitJacobianType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Partial':
            obj_ = PartialType.factory()
            obj_.build(child_)
            self.Partial.append(obj_)
        super(ExplicitJacobianType, self).buildChildren(child_, node, nodeName_, True)
# end class ExplicitJacobianType


class DirectActionType(NonInlinableIntrinsicBaseType):
    subclass = None
    superclass = NonInlinableIntrinsicBaseType
    def __init__(self, nonSmooth=False, name=None, derivAction=None):
        super(DirectActionType, self).__init__(nonSmooth, name, )
        self.derivAction = _cast(None, derivAction)
        pass
    def factory(*args_, **kwargs_):
        if DirectActionType.subclass:
            return DirectActionType.subclass(*args_, **kwargs_)
        else:
            return DirectActionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_derivAction(self): return self.derivAction
    def set_derivAction(self, derivAction): self.derivAction = derivAction
    def export(self, outfile, level, namespace_='xaifnii:', name_='DirectActionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DirectActionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='DirectActionType'):
        super(DirectActionType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='DirectActionType')
        if self.derivAction is not None and 'derivAction' not in already_processed:
            already_processed.append('derivAction')
            outfile.write(' derivAction=%s' % (self.gds_format_string(quote_attrib(self.derivAction).encode(ExternalEncoding), input_name='derivAction'), ))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='DirectActionType', fromsubclass_=False):
        super(DirectActionType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(DirectActionType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DirectActionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.derivAction is not None and 'derivAction' not in already_processed:
            already_processed.append('derivAction')
            showIndent(outfile, level)
            outfile.write('derivAction = "%s",\n' % (self.derivAction,))
        super(DirectActionType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(DirectActionType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('derivAction', node)
        if value is not None and 'derivAction' not in already_processed:
            already_processed.append('derivAction')
            self.derivAction = value
        super(DirectActionType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(DirectActionType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class DirectActionType


class NonInlinableIntrinsicDefinitions(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, ExplicitJacobian=None, DirectAction=None):
        if ExplicitJacobian is None:
            self.ExplicitJacobian = []
        else:
            self.ExplicitJacobian = ExplicitJacobian
        if DirectAction is None:
            self.DirectAction = []
        else:
            self.DirectAction = DirectAction
    def factory(*args_, **kwargs_):
        if NonInlinableIntrinsicDefinitions.subclass:
            return NonInlinableIntrinsicDefinitions.subclass(*args_, **kwargs_)
        else:
            return NonInlinableIntrinsicDefinitions(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExplicitJacobian(self): return self.ExplicitJacobian
    def set_ExplicitJacobian(self, ExplicitJacobian): self.ExplicitJacobian = ExplicitJacobian
    def add_ExplicitJacobian(self, value): self.ExplicitJacobian.append(value)
    def insert_ExplicitJacobian(self, index, value): self.ExplicitJacobian[index] = value
    def get_DirectAction(self): return self.DirectAction
    def set_DirectAction(self, DirectAction): self.DirectAction = DirectAction
    def add_DirectAction(self, value): self.DirectAction.append(value)
    def insert_DirectAction(self, index, value): self.DirectAction[index] = value
    def export(self, outfile, level, namespace_='xaifnii:', name_='NonInlinableIntrinsicDefinitions', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NonInlinableIntrinsicDefinitions')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='NonInlinableIntrinsicDefinitions'):
        pass
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='NonInlinableIntrinsicDefinitions', fromsubclass_=False):
        for ExplicitJacobian_ in self.ExplicitJacobian:
            ExplicitJacobian_.export(outfile, level, namespace_, name_='ExplicitJacobian')
        for DirectAction_ in self.DirectAction:
            DirectAction_.export(outfile, level, namespace_, name_='DirectAction')
    def hasContent_(self):
        if (
            self.ExplicitJacobian or
            self.DirectAction
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='NonInlinableIntrinsicDefinitions'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ExplicitJacobian=[\n')
        level += 1
        for ExplicitJacobian_ in self.ExplicitJacobian:
            showIndent(outfile, level)
            outfile.write('model_.ExplicitJacobianType(\n')
            ExplicitJacobian_.exportLiteral(outfile, level, name_='ExplicitJacobianType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('DirectAction=[\n')
        level += 1
        for DirectAction_ in self.DirectAction:
            showIndent(outfile, level)
            outfile.write('model_.DirectActionType(\n')
            DirectAction_.exportLiteral(outfile, level, name_='DirectActionType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExplicitJacobian':
            obj_ = ExplicitJacobianType.factory()
            obj_.build(child_)
            self.ExplicitJacobian.append(obj_)
        elif nodeName_ == 'DirectAction':
            obj_ = DirectActionType.factory()
            obj_.build(child_)
            self.DirectAction.append(obj_)
# end class NonInlinableIntrinsicDefinitions


class FrontEndAnnotationType(GeneratedsSuper):
    """This is used by the front-end to annotate elements in the XAIF file."""
    subclass = None
    superclass = None
    def __init__(self, annotation='', extensiontype_=None):
        self.annotation = _cast(None, annotation)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if FrontEndAnnotationType.subclass:
            return FrontEndAnnotationType.subclass(*args_, **kwargs_)
        else:
            return FrontEndAnnotationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_annotation(self): return self.annotation
    def set_annotation(self, annotation): self.annotation = annotation
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xaifnii:', name_='FrontEndAnnotationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FrontEndAnnotationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='FrontEndAnnotationType'):
        if self.annotation is not None and 'annotation' not in already_processed:
            already_processed.append('annotation')
            outfile.write(' annotation=%s' % (self.gds_format_string(quote_attrib(self.annotation).encode(ExternalEncoding), input_name='annotation'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='FrontEndAnnotationType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FrontEndAnnotationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.annotation is not None and 'annotation' not in already_processed:
            already_processed.append('annotation')
            showIndent(outfile, level)
            outfile.write('annotation = "%s",\n' % (self.annotation,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('annotation', node)
        if value is not None and 'annotation' not in already_processed:
            already_processed.append('annotation')
            self.annotation = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class FrontEndAnnotationType


class VertexType(FrontEndAnnotationType):
    """VertexType is abstract base type for vertices in XAIF graphs. Each
    vertex has a vertex_id that must be unique within the current
    graph. Whenever the graph consists of a single vertex only the
    vertex_id does not have to be specified and the default value
    "1" is used."""
    subclass = None
    superclass = FrontEndAnnotationType
    def __init__(self, annotation='', vertex_id='1', extensiontype_=None):
        super(VertexType, self).__init__(annotation, extensiontype_, )
        self.vertex_id = _cast(None, vertex_id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if VertexType.subclass:
            return VertexType.subclass(*args_, **kwargs_)
        else:
            return VertexType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_vertex_id(self): return self.vertex_id
    def set_vertex_id(self, vertex_id): self.vertex_id = vertex_id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xaifnii:', name_='VertexType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VertexType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='VertexType'):
        super(VertexType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VertexType')
        if self.vertex_id is not None and 'vertex_id' not in already_processed:
            already_processed.append('vertex_id')
            outfile.write(' vertex_id=%s' % (self.gds_format_string(quote_attrib(self.vertex_id).encode(ExternalEncoding), input_name='vertex_id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='VertexType', fromsubclass_=False):
        super(VertexType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(VertexType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VertexType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.vertex_id is not None and 'vertex_id' not in already_processed:
            already_processed.append('vertex_id')
            showIndent(outfile, level)
            outfile.write('vertex_id = "%s",\n' % (self.vertex_id,))
        super(VertexType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VertexType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('vertex_id', node)
        if value is not None and 'vertex_id' not in already_processed:
            already_processed.append('vertex_id')
            self.vertex_id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(VertexType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(VertexType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class VertexType


class EdgeType(FrontEndAnnotationType):
    """EdgeType is abstract base type for edges in XAIF graphs. Its
    attributes comprise a locally unique edge_id, the source, and
    the target. If only one edge is present, then the edge_id does
    not have to be specified and the default value "1" is used. Both
    source and target are vertex_id's of vertices in the
    corresponding XAIF graph."""
    subclass = None
    superclass = FrontEndAnnotationType
    def __init__(self, annotation='', source=None, target=None, edge_id=None, extensiontype_=None):
        super(EdgeType, self).__init__(annotation, extensiontype_, )
        self.source = _cast(None, source)
        self.target = _cast(None, target)
        self.edge_id = _cast(None, edge_id)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EdgeType.subclass:
            return EdgeType.subclass(*args_, **kwargs_)
        else:
            return EdgeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_source(self): return self.source
    def set_source(self, source): self.source = source
    def get_target(self): return self.target
    def set_target(self, target): self.target = target
    def get_edge_id(self): return self.edge_id
    def set_edge_id(self, edge_id): self.edge_id = edge_id
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xaifnii:', name_='EdgeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EdgeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='EdgeType'):
        super(EdgeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EdgeType')
        if self.source is not None and 'source' not in already_processed:
            already_processed.append('source')
            outfile.write(' source=%s' % (self.gds_format_string(quote_attrib(self.source).encode(ExternalEncoding), input_name='source'), ))
        if self.target is not None and 'target' not in already_processed:
            already_processed.append('target')
            outfile.write(' target=%s' % (self.gds_format_string(quote_attrib(self.target).encode(ExternalEncoding), input_name='target'), ))
        if self.edge_id is not None and 'edge_id' not in already_processed:
            already_processed.append('edge_id')
            outfile.write(' edge_id=%s' % (self.gds_format_string(quote_attrib(self.edge_id).encode(ExternalEncoding), input_name='edge_id'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='EdgeType', fromsubclass_=False):
        super(EdgeType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(EdgeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EdgeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.source is not None and 'source' not in already_processed:
            already_processed.append('source')
            showIndent(outfile, level)
            outfile.write('source = "%s",\n' % (self.source,))
        if self.target is not None and 'target' not in already_processed:
            already_processed.append('target')
            showIndent(outfile, level)
            outfile.write('target = "%s",\n' % (self.target,))
        if self.edge_id is not None and 'edge_id' not in already_processed:
            already_processed.append('edge_id')
            showIndent(outfile, level)
            outfile.write('edge_id = "%s",\n' % (self.edge_id,))
        super(EdgeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EdgeType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('source', node)
        if value is not None and 'source' not in already_processed:
            already_processed.append('source')
            self.source = value
        value = find_attr_value_('target', node)
        if value is not None and 'target' not in already_processed:
            already_processed.append('target')
            self.target = value
        value = find_attr_value_('edge_id', node)
        if value is not None and 'edge_id' not in already_processed:
            already_processed.append('edge_id')
            self.edge_id = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(EdgeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EdgeType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EdgeType


class DimensionBoundsType(GeneratedsSuper):
    """For vectors, matrices, etc that have fixed dimensions we provide
    dimension bounds."""
    subclass = None
    superclass = None
    def __init__(self, upper=None, lower=None):
        self.upper = _cast(int, upper)
        self.lower = _cast(int, lower)
        pass
    def factory(*args_, **kwargs_):
        if DimensionBoundsType.subclass:
            return DimensionBoundsType.subclass(*args_, **kwargs_)
        else:
            return DimensionBoundsType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_upper(self): return self.upper
    def set_upper(self, upper): self.upper = upper
    def get_lower(self): return self.lower
    def set_lower(self, lower): self.lower = lower
    def export(self, outfile, level, namespace_='xaifnii:', name_='DimensionBoundsType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DimensionBoundsType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='DimensionBoundsType'):
        if self.upper is not None and 'upper' not in already_processed:
            already_processed.append('upper')
            outfile.write(' upper="%s"' % self.gds_format_integer(self.upper, input_name='upper'))
        if self.lower is not None and 'lower' not in already_processed:
            already_processed.append('lower')
            outfile.write(' lower="%s"' % self.gds_format_integer(self.lower, input_name='lower'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='DimensionBoundsType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='DimensionBoundsType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.upper is not None and 'upper' not in already_processed:
            already_processed.append('upper')
            showIndent(outfile, level)
            outfile.write('upper = %d,\n' % (self.upper,))
        if self.lower is not None and 'lower' not in already_processed:
            already_processed.append('lower')
            showIndent(outfile, level)
            outfile.write('lower = %d,\n' % (self.lower,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('upper', node)
        if value is not None and 'upper' not in already_processed:
            already_processed.append('upper')
            try:
                self.upper = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('lower', node)
        if value is not None and 'lower' not in already_processed:
            already_processed.append('lower')
            try:
                self.lower = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class DimensionBoundsType


class SymbolType(FrontEndAnnotationType):
    """Symbols are stored in the symbol table. They are uniquely identified
    within the current scope (the current symbol table) by their
    symbol_id. Furthermore, we store their kind, type, and shape. By
    default, we consider real scalar variables. Vectors, matrices
    etc. can have variable dimensions and then there is nothing in
    the DimensionBoundsGroup. But if they are fixed we assume we
    have fixed bounds for ALL dimensions and expect a list of (max
    5, because we only have five_tensor right now) all dimension
    bounds. For cases where the front-end distinguishes machine
    dependent types, e.g. sizes in bytes, the front-end can use the
    optional fe_type attribute. We do not assign any particular
    meaning to values other than the empty string which means
    unspecified."""
    subclass = None
    superclass = FrontEndAnnotationType
    def __init__(self, annotation='', kind='variable', symbol_id=None, temp=False, feType='', shape='scalar', active=True, type_='real', pointer=False, DimensionBounds=None):
        super(SymbolType, self).__init__(annotation, )
        self.kind = _cast(None, kind)
        self.symbol_id = _cast(None, symbol_id)
        self.temp = _cast(bool, temp)
        self.feType = _cast(None, feType)
        self.shape = _cast(None, shape)
        self.active = _cast(bool, active)
        self.type_ = _cast(None, type_)
        self.pointer = _cast(bool, pointer)
        self.DimensionBounds = DimensionBounds
    def factory(*args_, **kwargs_):
        if SymbolType.subclass:
            return SymbolType.subclass(*args_, **kwargs_)
        else:
            return SymbolType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DimensionBounds(self): return self.DimensionBounds
    def set_DimensionBounds(self, DimensionBounds): self.DimensionBounds = DimensionBounds
    def get_kind(self): return self.kind
    def set_kind(self, kind): self.kind = kind
    def validate_SymbolKindType(self, value):
        # Validate type SymbolKindType, a restriction on xsd:string.
        pass
    def get_symbol_id(self): return self.symbol_id
    def set_symbol_id(self, symbol_id): self.symbol_id = symbol_id
    def get_temp(self): return self.temp
    def set_temp(self, temp): self.temp = temp
    def get_feType(self): return self.feType
    def set_feType(self, feType): self.feType = feType
    def get_shape(self): return self.shape
    def set_shape(self, shape): self.shape = shape
    def validate_SymbolShapeType(self, value):
        # Validate type SymbolShapeType, a restriction on xsd:string.
        pass
    def get_active(self): return self.active
    def set_active(self, active): self.active = active
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_SymbolTypeType(self, value):
        # Validate type SymbolTypeType, a restriction on xsd:string.
        pass
    def get_pointer(self): return self.pointer
    def set_pointer(self, pointer): self.pointer = pointer
    def export(self, outfile, level, namespace_='xaifnii:', name_='SymbolType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SymbolType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='SymbolType'):
        super(SymbolType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SymbolType')
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.append('kind')
            outfile.write(' kind=%s' % (quote_attrib(self.kind), ))
        if self.symbol_id is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            outfile.write(' symbol_id=%s' % (self.gds_format_string(quote_attrib(self.symbol_id).encode(ExternalEncoding), input_name='symbol_id'), ))
        if self.temp is not None and 'temp' not in already_processed:
            already_processed.append('temp')
            outfile.write(' temp="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.temp)), input_name='temp'))
        if self.feType is not None and 'feType' not in already_processed:
            already_processed.append('feType')
            outfile.write(' feType=%s' % (self.gds_format_string(quote_attrib(self.feType).encode(ExternalEncoding), input_name='feType'), ))
        if self.shape is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            outfile.write(' shape=%s' % (quote_attrib(self.shape), ))
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            outfile.write(' active="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.active)), input_name='active'))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.pointer is not None and 'pointer' not in already_processed:
            already_processed.append('pointer')
            outfile.write(' pointer="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.pointer)), input_name='pointer'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='SymbolType', fromsubclass_=False):
        super(SymbolType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.DimensionBounds is not None:
            self.DimensionBounds.export(outfile, level, namespace_, name_='DimensionBounds')
    def hasContent_(self):
        if (
            self.DimensionBounds is not None or
            super(SymbolType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SymbolType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.kind is not None and 'kind' not in already_processed:
            already_processed.append('kind')
            showIndent(outfile, level)
            outfile.write('kind = "%s",\n' % (self.kind,))
        if self.symbol_id is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            showIndent(outfile, level)
            outfile.write('symbol_id = "%s",\n' % (self.symbol_id,))
        if self.temp is not None and 'temp' not in already_processed:
            already_processed.append('temp')
            showIndent(outfile, level)
            outfile.write('temp = %s,\n' % (self.temp,))
        if self.feType is not None and 'feType' not in already_processed:
            already_processed.append('feType')
            showIndent(outfile, level)
            outfile.write('feType = "%s",\n' % (self.feType,))
        if self.shape is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            showIndent(outfile, level)
            outfile.write('shape = "%s",\n' % (self.shape,))
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            showIndent(outfile, level)
            outfile.write('active = %s,\n' % (self.active,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.pointer is not None and 'pointer' not in already_processed:
            already_processed.append('pointer')
            showIndent(outfile, level)
            outfile.write('pointer = %s,\n' % (self.pointer,))
        super(SymbolType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SymbolType, self).exportLiteralChildren(outfile, level, name_)
        if self.DimensionBounds is not None:
            showIndent(outfile, level)
            outfile.write('DimensionBounds=model_.DimensionBoundsType(\n')
            self.DimensionBounds.exportLiteral(outfile, level, name_='DimensionBounds')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('kind', node)
        if value is not None and 'kind' not in already_processed:
            already_processed.append('kind')
            self.kind = value
            self.validate_SymbolKindType(self.kind)    # validate type SymbolKindType
        value = find_attr_value_('symbol_id', node)
        if value is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            self.symbol_id = value
        value = find_attr_value_('temp', node)
        if value is not None and 'temp' not in already_processed:
            already_processed.append('temp')
            if value in ('true', '1'):
                self.temp = True
            elif value in ('false', '0'):
                self.temp = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('feType', node)
        if value is not None and 'feType' not in already_processed:
            already_processed.append('feType')
            self.feType = value
        value = find_attr_value_('shape', node)
        if value is not None and 'shape' not in already_processed:
            already_processed.append('shape')
            self.shape = value
            self.validate_SymbolShapeType(self.shape)    # validate type SymbolShapeType
        value = find_attr_value_('active', node)
        if value is not None and 'active' not in already_processed:
            already_processed.append('active')
            if value in ('true', '1'):
                self.active = True
            elif value in ('false', '0'):
                self.active = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.validate_SymbolTypeType(self.type_)    # validate type SymbolTypeType
        value = find_attr_value_('pointer', node)
        if value is not None and 'pointer' not in already_processed:
            already_processed.append('pointer')
            if value in ('true', '1'):
                self.pointer = True
            elif value in ('false', '0'):
                self.pointer = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(SymbolType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DimensionBounds':
            obj_ = DimensionBoundsType.factory()
            obj_.build(child_)
            self.set_DimensionBounds(obj_)
        super(SymbolType, self).buildChildren(child_, node, nodeName_, True)
# end class SymbolType


class SymbolTableType(GeneratedsSuper):
    """The symbol table is a list of one or more symbols."""
    subclass = None
    superclass = None
    def __init__(self, Symbol=None):
        if Symbol is None:
            self.Symbol = []
        else:
            self.Symbol = Symbol
    def factory(*args_, **kwargs_):
        if SymbolTableType.subclass:
            return SymbolTableType.subclass(*args_, **kwargs_)
        else:
            return SymbolTableType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Symbol(self): return self.Symbol
    def set_Symbol(self, Symbol): self.Symbol = Symbol
    def add_Symbol(self, value): self.Symbol.append(value)
    def insert_Symbol(self, index, value): self.Symbol[index] = value
    def export(self, outfile, level, namespace_='xaifnii:', name_='SymbolTableType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SymbolTableType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='SymbolTableType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='SymbolTableType', fromsubclass_=False):
        for Symbol_ in self.Symbol:
            Symbol_.export(outfile, level, namespace_, name_='Symbol')
    def hasContent_(self):
        if (
            self.Symbol
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SymbolTableType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Symbol=[\n')
        level += 1
        for Symbol_ in self.Symbol:
            showIndent(outfile, level)
            outfile.write('model_.SymbolType(\n')
            Symbol_.exportLiteral(outfile, level, name_='SymbolType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Symbol':
            obj_ = SymbolType.factory()
            obj_.build(child_)
            self.Symbol.append(obj_)
# end class SymbolTableType


class ScopeHierarchyType(GeneratedsSuper):
    """The scope hierarchy is a tree with a root representing the global
    scope. The global scope usually contains the name of the top-
    level routine, the names of its arguments, and any global
    symbols."""
    subclass = None
    superclass = None
    def __init__(self, Scope=None, ScopeEdge=None):
        if Scope is None:
            self.Scope = []
        else:
            self.Scope = Scope
        if ScopeEdge is None:
            self.ScopeEdge = []
        else:
            self.ScopeEdge = ScopeEdge
    def factory(*args_, **kwargs_):
        if ScopeHierarchyType.subclass:
            return ScopeHierarchyType.subclass(*args_, **kwargs_)
        else:
            return ScopeHierarchyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Scope(self): return self.Scope
    def set_Scope(self, Scope): self.Scope = Scope
    def add_Scope(self, value): self.Scope.append(value)
    def insert_Scope(self, index, value): self.Scope[index] = value
    def get_ScopeEdge(self): return self.ScopeEdge
    def set_ScopeEdge(self, ScopeEdge): self.ScopeEdge = ScopeEdge
    def add_ScopeEdge(self, value): self.ScopeEdge.append(value)
    def insert_ScopeEdge(self, index, value): self.ScopeEdge[index] = value
    def export(self, outfile, level, namespace_='xaifnii:', name_='ScopeHierarchyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScopeHierarchyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ScopeHierarchyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ScopeHierarchyType', fromsubclass_=False):
        for Scope_ in self.Scope:
            Scope_.export(outfile, level, namespace_, name_='Scope')
        for ScopeEdge_ in self.ScopeEdge:
            ScopeEdge_.export(outfile, level, namespace_, name_='ScopeEdge')
    def hasContent_(self):
        if (
            self.Scope or
            self.ScopeEdge
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ScopeHierarchyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Scope=[\n')
        level += 1
        for Scope_ in self.Scope:
            showIndent(outfile, level)
            outfile.write('model_.ScopeType1(\n')
            Scope_.exportLiteral(outfile, level, name_='ScopeType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ScopeEdge=[\n')
        level += 1
        for ScopeEdge_ in self.ScopeEdge:
            showIndent(outfile, level)
            outfile.write('model_.EdgeType(\n')
            ScopeEdge_.exportLiteral(outfile, level, name_='EdgeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Scope':
            obj_ = ScopeType1.factory()
            obj_.build(child_)
            self.Scope.append(obj_)
        elif nodeName_ == 'ScopeEdge':
            class_obj_ = self.get_class_obj_(child_, EdgeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ScopeEdge.append(obj_)
# end class ScopeHierarchyType


class StatementIdRefType(GeneratedsSuper):
    """a reference to a statementId in an Assignment; can be an empty
    string if we refer to an out-of-scope Assignment"""
    subclass = None
    superclass = None
    def __init__(self, idRef=None):
        self.idRef = _cast(None, idRef)
        pass
    def factory(*args_, **kwargs_):
        if StatementIdRefType.subclass:
            return StatementIdRefType.subclass(*args_, **kwargs_)
        else:
            return StatementIdRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_idRef(self): return self.idRef
    def set_idRef(self, idRef): self.idRef = idRef
    def export(self, outfile, level, namespace_='xaifnii:', name_='StatementIdRefType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StatementIdRefType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='StatementIdRefType'):
        if self.idRef is not None and 'idRef' not in already_processed:
            already_processed.append('idRef')
            outfile.write(' idRef=%s' % (self.gds_format_string(quote_attrib(self.idRef).encode(ExternalEncoding), input_name='idRef'), ))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='StatementIdRefType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StatementIdRefType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.idRef is not None and 'idRef' not in already_processed:
            already_processed.append('idRef')
            showIndent(outfile, level)
            outfile.write('idRef = "%s",\n' % (self.idRef,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('idRef', node)
        if value is not None and 'idRef' not in already_processed:
            already_processed.append('idRef')
            self.idRef = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class StatementIdRefType


class StmtIdSetWithKeyType(GeneratedsSuper):
    """a set of statement IDs a unique key into a map consisting of
    StmtIdSetWithKeyType instances"""
    subclass = None
    superclass = None
    def __init__(self, key=None, StatementId=None):
        self.key = _cast(int, key)
        if StatementId is None:
            self.StatementId = []
        else:
            self.StatementId = StatementId
    def factory(*args_, **kwargs_):
        if StmtIdSetWithKeyType.subclass:
            return StmtIdSetWithKeyType.subclass(*args_, **kwargs_)
        else:
            return StmtIdSetWithKeyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StatementId(self): return self.StatementId
    def set_StatementId(self, StatementId): self.StatementId = StatementId
    def add_StatementId(self, value): self.StatementId.append(value)
    def insert_StatementId(self, index, value): self.StatementId[index] = value
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def export(self, outfile, level, namespace_='xaifnii:', name_='StmtIdSetWithKeyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StmtIdSetWithKeyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='StmtIdSetWithKeyType'):
        if self.key is not None and 'key' not in already_processed:
            already_processed.append('key')
            outfile.write(' key="%s"' % self.gds_format_integer(self.key, input_name='key'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='StmtIdSetWithKeyType', fromsubclass_=False):
        for StatementId_ in self.StatementId:
            StatementId_.export(outfile, level, namespace_, name_='StatementId')
    def hasContent_(self):
        if (
            self.StatementId
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StmtIdSetWithKeyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.key is not None and 'key' not in already_processed:
            already_processed.append('key')
            showIndent(outfile, level)
            outfile.write('key = %d,\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('StatementId=[\n')
        level += 1
        for StatementId_ in self.StatementId:
            showIndent(outfile, level)
            outfile.write('model_.StatementIdRefType(\n')
            StatementId_.exportLiteral(outfile, level, name_='StatementIdRefType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.append('key')
            try:
                self.key = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.key < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StatementId':
            obj_ = StatementIdRefType.factory()
            obj_.build(child_)
            self.StatementId.append(obj_)
# end class StmtIdSetWithKeyType


class StmtIdSetMapType(GeneratedsSuper):
    """a map of StmtIdSet elements"""
    subclass = None
    superclass = None
    def __init__(self, StmtIdSet=None):
        if StmtIdSet is None:
            self.StmtIdSet = []
        else:
            self.StmtIdSet = StmtIdSet
    def factory(*args_, **kwargs_):
        if StmtIdSetMapType.subclass:
            return StmtIdSetMapType.subclass(*args_, **kwargs_)
        else:
            return StmtIdSetMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_StmtIdSet(self): return self.StmtIdSet
    def set_StmtIdSet(self, StmtIdSet): self.StmtIdSet = StmtIdSet
    def add_StmtIdSet(self, value): self.StmtIdSet.append(value)
    def insert_StmtIdSet(self, index, value): self.StmtIdSet[index] = value
    def export(self, outfile, level, namespace_='xaifnii:', name_='StmtIdSetMapType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='StmtIdSetMapType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='StmtIdSetMapType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='StmtIdSetMapType', fromsubclass_=False):
        for StmtIdSet_ in self.StmtIdSet:
            StmtIdSet_.export(outfile, level, namespace_, name_='StmtIdSet')
    def hasContent_(self):
        if (
            self.StmtIdSet
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='StmtIdSetMapType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('StmtIdSet=[\n')
        level += 1
        for StmtIdSet_ in self.StmtIdSet:
            showIndent(outfile, level)
            outfile.write('model_.StmtIdSetWithKeyType(\n')
            StmtIdSet_.exportLiteral(outfile, level, name_='StmtIdSetWithKeyType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'StmtIdSet':
            obj_ = StmtIdSetWithKeyType.factory()
            obj_.build(child_)
            self.StmtIdSet.append(obj_)
# end class StmtIdSetMapType


class AliasRangeType(GeneratedsSuper):
    """An alias range is a range of virtual addresses where we assume
    from_virtual_address less than or equal to_virtual_address or
    the range is interpreted to be empty. The "partial" attribute
    signifies a partial reference, as opposed to a full reference,
    e.g. when we talk about a vector that has an address range and
    the entire vector is read or written."""
    subclass = None
    superclass = None
    def __init__(self, from_virtual_address=None, to_virtual_address=None, partial=True):
        self.from_virtual_address = _cast(int, from_virtual_address)
        self.to_virtual_address = _cast(int, to_virtual_address)
        self.partial = _cast(bool, partial)
        pass
    def factory(*args_, **kwargs_):
        if AliasRangeType.subclass:
            return AliasRangeType.subclass(*args_, **kwargs_)
        else:
            return AliasRangeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_from_virtual_address(self): return self.from_virtual_address
    def set_from_virtual_address(self, from_virtual_address): self.from_virtual_address = from_virtual_address
    def get_to_virtual_address(self): return self.to_virtual_address
    def set_to_virtual_address(self, to_virtual_address): self.to_virtual_address = to_virtual_address
    def get_partial(self): return self.partial
    def set_partial(self, partial): self.partial = partial
    def export(self, outfile, level, namespace_='xaifnii:', name_='AliasRangeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AliasRangeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='AliasRangeType'):
        if self.from_virtual_address is not None and 'from_virtual_address' not in already_processed:
            already_processed.append('from_virtual_address')
            outfile.write(' from_virtual_address="%s"' % self.gds_format_integer(self.from_virtual_address, input_name='from_virtual_address'))
        if self.to_virtual_address is not None and 'to_virtual_address' not in already_processed:
            already_processed.append('to_virtual_address')
            outfile.write(' to_virtual_address="%s"' % self.gds_format_integer(self.to_virtual_address, input_name='to_virtual_address'))
        if self.partial is not None and 'partial' not in already_processed:
            already_processed.append('partial')
            outfile.write(' partial="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.partial)), input_name='partial'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='AliasRangeType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AliasRangeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.from_virtual_address is not None and 'from_virtual_address' not in already_processed:
            already_processed.append('from_virtual_address')
            showIndent(outfile, level)
            outfile.write('from_virtual_address = %d,\n' % (self.from_virtual_address,))
        if self.to_virtual_address is not None and 'to_virtual_address' not in already_processed:
            already_processed.append('to_virtual_address')
            showIndent(outfile, level)
            outfile.write('to_virtual_address = %d,\n' % (self.to_virtual_address,))
        if self.partial is not None and 'partial' not in already_processed:
            already_processed.append('partial')
            showIndent(outfile, level)
            outfile.write('partial = %s,\n' % (self.partial,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('from_virtual_address', node)
        if value is not None and 'from_virtual_address' not in already_processed:
            already_processed.append('from_virtual_address')
            try:
                self.from_virtual_address = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.from_virtual_address <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('to_virtual_address', node)
        if value is not None and 'to_virtual_address' not in already_processed:
            already_processed.append('to_virtual_address')
            try:
                self.to_virtual_address = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.to_virtual_address <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('partial', node)
        if value is not None and 'partial' not in already_processed:
            already_processed.append('partial')
            if value in ('true', '1'):
                self.partial = True
            elif value in ('false', '0'):
                self.partial = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class AliasRangeType


class AliasSetType(GeneratedsSuper):
    """A set of alias information consisting of ranges of virtual
    addresses. The "0" key entry signifies the "alias all". This
    entry may or may not be empty, its content is irrelevant. It
    needs to exist to satisfy the referential integrity constraints
    (as_keyref1/2) for "alias" foreign key attributes defaulting to
    "0" in case no actual alias information is available. There may
    be empty AliasSets, for instance for the case of "address being
    taken", i.e. a computed value that does not have a storage
    location."""
    subclass = None
    superclass = None
    def __init__(self, key=None, AliasRange=None):
        self.key = _cast(int, key)
        if AliasRange is None:
            self.AliasRange = []
        else:
            self.AliasRange = AliasRange
    def factory(*args_, **kwargs_):
        if AliasSetType.subclass:
            return AliasSetType.subclass(*args_, **kwargs_)
        else:
            return AliasSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AliasRange(self): return self.AliasRange
    def set_AliasRange(self, AliasRange): self.AliasRange = AliasRange
    def add_AliasRange(self, value): self.AliasRange.append(value)
    def insert_AliasRange(self, index, value): self.AliasRange[index] = value
    def get_key(self): return self.key
    def set_key(self, key): self.key = key
    def export(self, outfile, level, namespace_='xaifnii:', name_='AliasSetType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AliasSetType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='AliasSetType'):
        if self.key is not None and 'key' not in already_processed:
            already_processed.append('key')
            outfile.write(' key="%s"' % self.gds_format_integer(self.key, input_name='key'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='AliasSetType', fromsubclass_=False):
        for AliasRange_ in self.AliasRange:
            AliasRange_.export(outfile, level, namespace_, name_='AliasRange')
    def hasContent_(self):
        if (
            self.AliasRange
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AliasSetType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.key is not None and 'key' not in already_processed:
            already_processed.append('key')
            showIndent(outfile, level)
            outfile.write('key = %d,\n' % (self.key,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AliasRange=[\n')
        level += 1
        for AliasRange_ in self.AliasRange:
            showIndent(outfile, level)
            outfile.write('model_.AliasRangeType(\n')
            AliasRange_.exportLiteral(outfile, level, name_='AliasRangeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('key', node)
        if value is not None and 'key' not in already_processed:
            already_processed.append('key')
            try:
                self.key = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.key < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AliasRange':
            obj_ = AliasRangeType.factory()
            obj_.build(child_)
            self.AliasRange.append(obj_)
# end class AliasSetType


class AliasSetMapType(GeneratedsSuper):
    """a map of Alias Sets with key as a unique identifier to be referenced
    from variables."""
    subclass = None
    superclass = None
    def __init__(self, AliasSet=None):
        if AliasSet is None:
            self.AliasSet = []
        else:
            self.AliasSet = AliasSet
    def factory(*args_, **kwargs_):
        if AliasSetMapType.subclass:
            return AliasSetMapType.subclass(*args_, **kwargs_)
        else:
            return AliasSetMapType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AliasSet(self): return self.AliasSet
    def set_AliasSet(self, AliasSet): self.AliasSet = AliasSet
    def add_AliasSet(self, value): self.AliasSet.append(value)
    def insert_AliasSet(self, index, value): self.AliasSet[index] = value
    def export(self, outfile, level, namespace_='xaifnii:', name_='AliasSetMapType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AliasSetMapType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='AliasSetMapType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='AliasSetMapType', fromsubclass_=False):
        for AliasSet_ in self.AliasSet:
            AliasSet_.export(outfile, level, namespace_, name_='AliasSet')
    def hasContent_(self):
        if (
            self.AliasSet
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AliasSetMapType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('AliasSet=[\n')
        level += 1
        for AliasSet_ in self.AliasSet:
            showIndent(outfile, level)
            outfile.write('model_.AliasSetType(\n')
            AliasSet_.exportLiteral(outfile, level, name_='AliasSetType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AliasSet':
            obj_ = AliasSetType.factory()
            obj_.build(child_)
            self.AliasSet.append(obj_)
# end class AliasSetMapType


class CallGraphType(GeneratedsSuper):
    """The call graph is the root element of any XAIF file. It contains the
    scope hierarchy, lists of independent and dependent variables,
    call graph vertices and edges. The name of the top-level routine
    must be specified. Optionally, a program_name can be assigned.
    An attribute specifying a prefix for any symbol created by
    xaifbooster.It should be unique for each pass through
    xaifbooster to avoid name clashes. The default will be removed
    and it will be changed to 'required'."""
    subclass = None
    superclass = None
    def __init__(self, program_name=None, prefix='GetRidOfThisDefault', ScopeHierarchy=None, AliasSetMap=None, DUUDSetMap=None, DOSetMap=None, CallGraphVertex=None, CallGraphEdge=None):
        self.program_name = _cast(None, program_name)
        self.prefix = _cast(None, prefix)
        self.ScopeHierarchy = ScopeHierarchy
        self.AliasSetMap = AliasSetMap
        self.DUUDSetMap = DUUDSetMap
        self.DOSetMap = DOSetMap
        self.CallGraphVertex = CallGraphVertex
        self.CallGraphEdge = CallGraphEdge
    def factory(*args_, **kwargs_):
        if CallGraphType.subclass:
            return CallGraphType.subclass(*args_, **kwargs_)
        else:
            return CallGraphType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ScopeHierarchy(self): return self.ScopeHierarchy
    def set_ScopeHierarchy(self, ScopeHierarchy): self.ScopeHierarchy = ScopeHierarchy
    def get_AliasSetMap(self): return self.AliasSetMap
    def set_AliasSetMap(self, AliasSetMap): self.AliasSetMap = AliasSetMap
    def get_DUUDSetMap(self): return self.DUUDSetMap
    def set_DUUDSetMap(self, DUUDSetMap): self.DUUDSetMap = DUUDSetMap
    def get_DOSetMap(self): return self.DOSetMap
    def set_DOSetMap(self, DOSetMap): self.DOSetMap = DOSetMap
    def get_CallGraphVertex(self): return self.CallGraphVertex
    def set_CallGraphVertex(self, CallGraphVertex): self.CallGraphVertex = CallGraphVertex
    def get_CallGraphEdge(self): return self.CallGraphEdge
    def set_CallGraphEdge(self, CallGraphEdge): self.CallGraphEdge = CallGraphEdge
    def get_program_name(self): return self.program_name
    def set_program_name(self, program_name): self.program_name = program_name
    def get_prefix(self): return self.prefix
    def set_prefix(self, prefix): self.prefix = prefix
    def export(self, outfile, level, namespace_='xaifnii:', name_='CallGraphType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CallGraphType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='CallGraphType'):
        if self.program_name is not None and 'program_name' not in already_processed:
            already_processed.append('program_name')
            outfile.write(' program_name=%s' % (self.gds_format_string(quote_attrib(self.program_name).encode(ExternalEncoding), input_name='program_name'), ))
        if self.prefix is not None and 'prefix' not in already_processed:
            already_processed.append('prefix')
            outfile.write(' prefix=%s' % (self.gds_format_string(quote_attrib(self.prefix).encode(ExternalEncoding), input_name='prefix'), ))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='CallGraphType', fromsubclass_=False):
        if self.ScopeHierarchy is not None:
            self.ScopeHierarchy.export(outfile, level, namespace_, name_='ScopeHierarchy', )
        if self.AliasSetMap is not None:
            self.AliasSetMap.export(outfile, level, namespace_, name_='AliasSetMap', )
        if self.DUUDSetMap is not None:
            self.DUUDSetMap.export(outfile, level, namespace_, name_='DUUDSetMap', )
        if self.DOSetMap is not None:
            self.DOSetMap.export(outfile, level, namespace_, name_='DOSetMap', )
        if self.CallGraphVertex is not None:
            self.CallGraphVertex.export(outfile, level, namespace_, name_='CallGraphVertex', )
        if self.CallGraphEdge is not None:
            self.CallGraphEdge.export(outfile, level, namespace_, name_='CallGraphEdge', )
    def hasContent_(self):
        if (
            self.ScopeHierarchy is not None or
            self.AliasSetMap is not None or
            self.DUUDSetMap is not None or
            self.DOSetMap is not None or
            self.CallGraphVertex is not None or
            self.CallGraphEdge is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='CallGraphType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.program_name is not None and 'program_name' not in already_processed:
            already_processed.append('program_name')
            showIndent(outfile, level)
            outfile.write('program_name = "%s",\n' % (self.program_name,))
        if self.prefix is not None and 'prefix' not in already_processed:
            already_processed.append('prefix')
            showIndent(outfile, level)
            outfile.write('prefix = "%s",\n' % (self.prefix,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ScopeHierarchy is not None:
            showIndent(outfile, level)
            outfile.write('ScopeHierarchy=model_.ScopeHierarchy(\n')
            self.ScopeHierarchy.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AliasSetMap is not None:
            showIndent(outfile, level)
            outfile.write('AliasSetMap=model_.AliasSetMap(\n')
            self.AliasSetMap.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DUUDSetMap is not None:
            showIndent(outfile, level)
            outfile.write('DUUDSetMap=model_.DUUDSetMap(\n')
            self.DUUDSetMap.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DOSetMap is not None:
            showIndent(outfile, level)
            outfile.write('DOSetMap=model_.DOSetMap(\n')
            self.DOSetMap.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CallGraphVertex is not None:
            showIndent(outfile, level)
            outfile.write('CallGraphVertex=model_.CallGraphVertex(\n')
            self.CallGraphVertex.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CallGraphEdge is not None:
            showIndent(outfile, level)
            outfile.write('CallGraphEdge=model_.EdgeType(\n')
            self.CallGraphEdge.exportLiteral(outfile, level, name_='CallGraphEdge')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('program_name', node)
        if value is not None and 'program_name' not in already_processed:
            already_processed.append('program_name')
            self.program_name = value
        value = find_attr_value_('prefix', node)
        if value is not None and 'prefix' not in already_processed:
            already_processed.append('prefix')
            self.prefix = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ScopeHierarchy':
            obj_ = ScopeHierarchyType.factory()
            obj_.build(child_)
            self.set_ScopeHierarchy(obj_)
        elif nodeName_ == 'AliasSetMap':
            obj_ = AliasSetMapType.factory()
            obj_.build(child_)
            self.set_AliasSetMap(obj_)
        elif nodeName_ == 'DUUDSetMap':
            obj_ = StmtIdSetMapType.factory()
            obj_.build(child_)
            self.set_DUUDSetMap(obj_)
        elif nodeName_ == 'DOSetMap':
            obj_ = StmtIdSetMapType.factory()
            obj_.build(child_)
            self.set_DOSetMap(obj_)
        elif nodeName_ == 'CallGraphVertex':
            class_obj_ = self.get_class_obj_(child_, VertexType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_CallGraphVertex(obj_)
        elif nodeName_ == 'ControlFlowGraph':
            obj_ = ControlFlowGraphType.factory()
            obj_.build(child_)
            self.set_CallGraphVertex(obj_)
        elif nodeName_ == 'CallGraphEdge':
            class_obj_ = self.get_class_obj_(child_, EdgeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_CallGraphEdge(obj_)
# end class CallGraphType


class ArgumentSymbolReferenceType(FrontEndAnnotationType):
    """An argument of a subroutine is a SymbolReference augmented by its
    position within the argument list where position is greater than
    0 and less or equal number of elements in ArgumentListType.
    Additionally, its intent (default: inout) may be specified."""
    subclass = None
    superclass = FrontEndAnnotationType
    def __init__(self, annotation='', position=None, scope_id=None, symbol_id=None, intent='inout', deriv=False):
        super(ArgumentSymbolReferenceType, self).__init__(annotation, )
        self.position = _cast(int, position)
        self.scope_id = _cast(int, scope_id)
        self.symbol_id = _cast(None, symbol_id)
        self.intent = _cast(None, intent)
        self.deriv = _cast(bool, deriv)
        pass
    def factory(*args_, **kwargs_):
        if ArgumentSymbolReferenceType.subclass:
            return ArgumentSymbolReferenceType.subclass(*args_, **kwargs_)
        else:
            return ArgumentSymbolReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def get_scope_id(self): return self.scope_id
    def set_scope_id(self, scope_id): self.scope_id = scope_id
    def get_symbol_id(self): return self.symbol_id
    def set_symbol_id(self, symbol_id): self.symbol_id = symbol_id
    def get_intent(self): return self.intent
    def set_intent(self, intent): self.intent = intent
    def validate_IntentType(self, value):
        # Validate type IntentType, a restriction on xsd:string.
        pass
    def get_deriv(self): return self.deriv
    def set_deriv(self, deriv): self.deriv = deriv
    def export(self, outfile, level, namespace_='xaifnii:', name_='ArgumentSymbolReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArgumentSymbolReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ArgumentSymbolReferenceType'):
        super(ArgumentSymbolReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ArgumentSymbolReferenceType')
        if self.position is not None and 'position' not in already_processed:
            already_processed.append('position')
            outfile.write(' position="%s"' % self.gds_format_integer(self.position, input_name='position'))
        if self.scope_id is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            outfile.write(' scope_id="%s"' % self.gds_format_integer(self.scope_id, input_name='scope_id'))
        if self.symbol_id is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            outfile.write(' symbol_id=%s' % (self.gds_format_string(quote_attrib(self.symbol_id).encode(ExternalEncoding), input_name='symbol_id'), ))
        if self.intent is not None and 'intent' not in already_processed:
            already_processed.append('intent')
            outfile.write(' intent=%s' % (quote_attrib(self.intent), ))
        if self.deriv is not None and 'deriv' not in already_processed:
            already_processed.append('deriv')
            outfile.write(' deriv="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.deriv)), input_name='deriv'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ArgumentSymbolReferenceType', fromsubclass_=False):
        super(ArgumentSymbolReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(ArgumentSymbolReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArgumentSymbolReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.position is not None and 'position' not in already_processed:
            already_processed.append('position')
            showIndent(outfile, level)
            outfile.write('position = %d,\n' % (self.position,))
        if self.scope_id is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            showIndent(outfile, level)
            outfile.write('scope_id = %d,\n' % (self.scope_id,))
        if self.symbol_id is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            showIndent(outfile, level)
            outfile.write('symbol_id = "%s",\n' % (self.symbol_id,))
        if self.intent is not None and 'intent' not in already_processed:
            already_processed.append('intent')
            showIndent(outfile, level)
            outfile.write('intent = "%s",\n' % (self.intent,))
        if self.deriv is not None and 'deriv' not in already_processed:
            already_processed.append('deriv')
            showIndent(outfile, level)
            outfile.write('deriv = %s,\n' % (self.deriv,))
        super(ArgumentSymbolReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ArgumentSymbolReferenceType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.append('position')
            try:
                self.position = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.position <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('scope_id', node)
        if value is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            try:
                self.scope_id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.scope_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('symbol_id', node)
        if value is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            self.symbol_id = value
        value = find_attr_value_('intent', node)
        if value is not None and 'intent' not in already_processed:
            already_processed.append('intent')
            self.intent = value
            self.validate_IntentType(self.intent)    # validate type IntentType
        value = find_attr_value_('deriv', node)
        if value is not None and 'deriv' not in already_processed:
            already_processed.append('deriv')
            if value in ('true', '1'):
                self.deriv = True
            elif value in ('false', '0'):
                self.deriv = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(ArgumentSymbolReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ArgumentSymbolReferenceType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ArgumentSymbolReferenceType


class ArgumentListType(GeneratedsSuper):
    """The argument list."""
    subclass = None
    superclass = None
    def __init__(self, ArgumentSymbolReference=None):
        if ArgumentSymbolReference is None:
            self.ArgumentSymbolReference = []
        else:
            self.ArgumentSymbolReference = ArgumentSymbolReference
    def factory(*args_, **kwargs_):
        if ArgumentListType.subclass:
            return ArgumentListType.subclass(*args_, **kwargs_)
        else:
            return ArgumentListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ArgumentSymbolReference(self): return self.ArgumentSymbolReference
    def set_ArgumentSymbolReference(self, ArgumentSymbolReference): self.ArgumentSymbolReference = ArgumentSymbolReference
    def add_ArgumentSymbolReference(self, value): self.ArgumentSymbolReference.append(value)
    def insert_ArgumentSymbolReference(self, index, value): self.ArgumentSymbolReference[index] = value
    def export(self, outfile, level, namespace_='xaifnii:', name_='ArgumentListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArgumentListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ArgumentListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ArgumentListType', fromsubclass_=False):
        for ArgumentSymbolReference_ in self.ArgumentSymbolReference:
            ArgumentSymbolReference_.export(outfile, level, namespace_, name_='ArgumentSymbolReference')
    def hasContent_(self):
        if (
            self.ArgumentSymbolReference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArgumentListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ArgumentSymbolReference=[\n')
        level += 1
        for ArgumentSymbolReference_ in self.ArgumentSymbolReference:
            showIndent(outfile, level)
            outfile.write('model_.ArgumentSymbolReferenceType(\n')
            ArgumentSymbolReference_.exportLiteral(outfile, level, name_='ArgumentSymbolReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ArgumentSymbolReference':
            obj_ = ArgumentSymbolReferenceType.factory()
            obj_.build(child_)
            self.ArgumentSymbolReference.append(obj_)
# end class ArgumentListType


class SideEffectListType(GeneratedsSuper):
    """A list of VariableReferences to express the results of sideeffect
    analysis."""
    subclass = None
    superclass = None
    def __init__(self, SideEffectReference=None):
        if SideEffectReference is None:
            self.SideEffectReference = []
        else:
            self.SideEffectReference = SideEffectReference
    def factory(*args_, **kwargs_):
        if SideEffectListType.subclass:
            return SideEffectListType.subclass(*args_, **kwargs_)
        else:
            return SideEffectListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SideEffectReference(self): return self.SideEffectReference
    def set_SideEffectReference(self, SideEffectReference): self.SideEffectReference = SideEffectReference
    def add_SideEffectReference(self, value): self.SideEffectReference.append(value)
    def insert_SideEffectReference(self, index, value): self.SideEffectReference[index] = value
    def export(self, outfile, level, namespace_='xaifnii:', name_='SideEffectListType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SideEffectListType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='SideEffectListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='SideEffectListType', fromsubclass_=False):
        for SideEffectReference_ in self.SideEffectReference:
            SideEffectReference_.export(outfile, level, namespace_, name_='SideEffectReference')
    def hasContent_(self):
        if (
            self.SideEffectReference
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SideEffectListType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('SideEffectReference=[\n')
        level += 1
        for SideEffectReference_ in self.SideEffectReference:
            showIndent(outfile, level)
            outfile.write('model_.VariableReferenceType(\n')
            SideEffectReference_.exportLiteral(outfile, level, name_='VariableReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SideEffectReference':
            class_obj_ = self.get_class_obj_(child_, VariableReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.SideEffectReference.append(obj_)
# end class SideEffectListType


class ControlFlowGraphType(VertexType):
    """Subroutines are represented by control flow graphs. The name of the
    subroutine must be specified with the attributes below just like
    a SymbolReference. Subroutine arguments (if any) are specified
    in ArgumentList. We have four lists as the result of sideeffect
    analysis: ModLocal: modifications in this subroutine Mod:
    modifications in this subroutine and its callees ReadLocal:
    reads in this subroutine Read: reads in this subroutine and its
    callees and one list provided by the front-end: OnEntry: reads
    in this subroutine that have to be set on entry, e.g. because of
    uses in the declaration block The control flow graph itself is
    contained in ControlFlowVertexAndEdgeGroup. The control flow
    graph is considered structured if loops and branches are nested
    or arranged in a sequence so that for every loop and branch node
    there is corresponding end node so that each control flow path
    through a given loop or branch has to traverse the corresponding
    endLoop or endBranch node. This excludes early returns,
    alternative entries, ..."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', active=True, structured=True, scope_id=None, symbol_id=None, controlflowgraph_scope_id=None, ArgumentList=None, ModLocal=None, Mod=None, ReadLocal=None, Read=None, OnEntry=None, ControlFlowVertex=None, ControlFlowEdge=None):
        super(ControlFlowGraphType, self).__init__(annotation, vertex_id, )
        self.active = _cast(bool, active)
        self.structured = _cast(bool, structured)
        self.scope_id = _cast(int, scope_id)
        self.symbol_id = _cast(None, symbol_id)
        self.controlflowgraph_scope_id = _cast(int, controlflowgraph_scope_id)
        self.ArgumentList = ArgumentList
        self.ModLocal = ModLocal
        self.Mod = Mod
        self.ReadLocal = ReadLocal
        self.Read = Read
        self.OnEntry = OnEntry
        if ControlFlowVertex is None:
            self.ControlFlowVertex = []
        else:
            self.ControlFlowVertex = ControlFlowVertex
        if ControlFlowEdge is None:
            self.ControlFlowEdge = []
        else:
            self.ControlFlowEdge = ControlFlowEdge
    def factory(*args_, **kwargs_):
        if ControlFlowGraphType.subclass:
            return ControlFlowGraphType.subclass(*args_, **kwargs_)
        else:
            return ControlFlowGraphType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ArgumentList(self): return self.ArgumentList
    def set_ArgumentList(self, ArgumentList): self.ArgumentList = ArgumentList
    def get_ModLocal(self): return self.ModLocal
    def set_ModLocal(self, ModLocal): self.ModLocal = ModLocal
    def get_Mod(self): return self.Mod
    def set_Mod(self, Mod): self.Mod = Mod
    def get_ReadLocal(self): return self.ReadLocal
    def set_ReadLocal(self, ReadLocal): self.ReadLocal = ReadLocal
    def get_Read(self): return self.Read
    def set_Read(self, Read): self.Read = Read
    def get_OnEntry(self): return self.OnEntry
    def set_OnEntry(self, OnEntry): self.OnEntry = OnEntry
    def get_ControlFlowVertex(self): return self.ControlFlowVertex
    def set_ControlFlowVertex(self, ControlFlowVertex): self.ControlFlowVertex = ControlFlowVertex
    def add_ControlFlowVertex(self, value): self.ControlFlowVertex.append(value)
    def insert_ControlFlowVertex(self, index, value): self.ControlFlowVertex[index] = value
    def get_ControlFlowEdge(self): return self.ControlFlowEdge
    def set_ControlFlowEdge(self, ControlFlowEdge): self.ControlFlowEdge = ControlFlowEdge
    def add_ControlFlowEdge(self, value): self.ControlFlowEdge.append(value)
    def insert_ControlFlowEdge(self, index, value): self.ControlFlowEdge[index] = value
    def get_active(self): return self.active
    def set_active(self, active): self.active = active
    def get_structured(self): return self.structured
    def set_structured(self, structured): self.structured = structured
    def get_scope_id(self): return self.scope_id
    def set_scope_id(self, scope_id): self.scope_id = scope_id
    def get_symbol_id(self): return self.symbol_id
    def set_symbol_id(self, symbol_id): self.symbol_id = symbol_id
    def get_controlflowgraph_scope_id(self): return self.controlflowgraph_scope_id
    def set_controlflowgraph_scope_id(self, controlflowgraph_scope_id): self.controlflowgraph_scope_id = controlflowgraph_scope_id
    def export(self, outfile, level, namespace_='xaifnii:', name_='ControlFlowGraphType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ControlFlowGraphType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ControlFlowGraphType'):
        super(ControlFlowGraphType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ControlFlowGraphType')
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            outfile.write(' active="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.active)), input_name='active'))
        if self.structured is not None and 'structured' not in already_processed:
            already_processed.append('structured')
            outfile.write(' structured="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.structured)), input_name='structured'))
        if self.scope_id is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            outfile.write(' scope_id="%s"' % self.gds_format_integer(self.scope_id, input_name='scope_id'))
        if self.symbol_id is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            outfile.write(' symbol_id=%s' % (self.gds_format_string(quote_attrib(self.symbol_id).encode(ExternalEncoding), input_name='symbol_id'), ))
        if self.controlflowgraph_scope_id is not None and 'controlflowgraph_scope_id' not in already_processed:
            already_processed.append('controlflowgraph_scope_id')
            outfile.write(' controlflowgraph_scope_id="%s"' % self.gds_format_integer(self.controlflowgraph_scope_id, input_name='controlflowgraph_scope_id'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ControlFlowGraphType', fromsubclass_=False):
        super(ControlFlowGraphType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.ArgumentList is not None:
            self.ArgumentList.export(outfile, level, namespace_, name_='ArgumentList')
        if self.ModLocal is not None:
            self.ModLocal.export(outfile, level, namespace_, name_='ModLocal')
        if self.Mod is not None:
            self.Mod.export(outfile, level, namespace_, name_='Mod')
        if self.ReadLocal is not None:
            self.ReadLocal.export(outfile, level, namespace_, name_='ReadLocal')
        if self.Read is not None:
            self.Read.export(outfile, level, namespace_, name_='Read')
        if self.OnEntry is not None:
            self.OnEntry.export(outfile, level, namespace_, name_='OnEntry')
        for ControlFlowVertex_ in self.ControlFlowVertex:
            ControlFlowVertex_.export(outfile, level, namespace_, name_='ControlFlowVertex')
        for ControlFlowEdge_ in self.ControlFlowEdge:
            ControlFlowEdge_.export(outfile, level, namespace_, name_='ControlFlowEdge')
    def hasContent_(self):
        if (
            self.ArgumentList is not None or
            self.ModLocal is not None or
            self.Mod is not None or
            self.ReadLocal is not None or
            self.Read is not None or
            self.OnEntry is not None or
            self.ControlFlowVertex or
            self.ControlFlowEdge or
            super(ControlFlowGraphType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ControlFlowGraphType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            showIndent(outfile, level)
            outfile.write('active = %s,\n' % (self.active,))
        if self.structured is not None and 'structured' not in already_processed:
            already_processed.append('structured')
            showIndent(outfile, level)
            outfile.write('structured = %s,\n' % (self.structured,))
        if self.scope_id is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            showIndent(outfile, level)
            outfile.write('scope_id = %d,\n' % (self.scope_id,))
        if self.symbol_id is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            showIndent(outfile, level)
            outfile.write('symbol_id = "%s",\n' % (self.symbol_id,))
        if self.controlflowgraph_scope_id is not None and 'controlflowgraph_scope_id' not in already_processed:
            already_processed.append('controlflowgraph_scope_id')
            showIndent(outfile, level)
            outfile.write('controlflowgraph_scope_id = %d,\n' % (self.controlflowgraph_scope_id,))
        super(ControlFlowGraphType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ControlFlowGraphType, self).exportLiteralChildren(outfile, level, name_)
        if self.ArgumentList is not None:
            showIndent(outfile, level)
            outfile.write('ArgumentList=model_.ArgumentListType(\n')
            self.ArgumentList.exportLiteral(outfile, level, name_='ArgumentList')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ModLocal is not None:
            showIndent(outfile, level)
            outfile.write('ModLocal=model_.SideEffectListType(\n')
            self.ModLocal.exportLiteral(outfile, level, name_='ModLocal')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Mod is not None:
            showIndent(outfile, level)
            outfile.write('Mod=model_.SideEffectListType(\n')
            self.Mod.exportLiteral(outfile, level, name_='Mod')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ReadLocal is not None:
            showIndent(outfile, level)
            outfile.write('ReadLocal=model_.SideEffectListType(\n')
            self.ReadLocal.exportLiteral(outfile, level, name_='ReadLocal')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Read is not None:
            showIndent(outfile, level)
            outfile.write('Read=model_.SideEffectListType(\n')
            self.Read.exportLiteral(outfile, level, name_='Read')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OnEntry is not None:
            showIndent(outfile, level)
            outfile.write('OnEntry=model_.SideEffectListType(\n')
            self.OnEntry.exportLiteral(outfile, level, name_='OnEntry')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('ControlFlowVertex=[\n')
        level += 1
        for ControlFlowVertex_ in self.ControlFlowVertex:
            showIndent(outfile, level)
            outfile.write('model_.ControlFlowVertex(\n')
            ControlFlowVertex_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ControlFlowEdge=[\n')
        level += 1
        for ControlFlowEdge_ in self.ControlFlowEdge:
            showIndent(outfile, level)
            outfile.write('model_.ControlFlowEdgeType(\n')
            ControlFlowEdge_.exportLiteral(outfile, level, name_='ControlFlowEdgeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('active', node)
        if value is not None and 'active' not in already_processed:
            already_processed.append('active')
            if value in ('true', '1'):
                self.active = True
            elif value in ('false', '0'):
                self.active = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('structured', node)
        if value is not None and 'structured' not in already_processed:
            already_processed.append('structured')
            if value in ('true', '1'):
                self.structured = True
            elif value in ('false', '0'):
                self.structured = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('scope_id', node)
        if value is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            try:
                self.scope_id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.scope_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('symbol_id', node)
        if value is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            self.symbol_id = value
        value = find_attr_value_('controlflowgraph_scope_id', node)
        if value is not None and 'controlflowgraph_scope_id' not in already_processed:
            already_processed.append('controlflowgraph_scope_id')
            try:
                self.controlflowgraph_scope_id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.controlflowgraph_scope_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        super(ControlFlowGraphType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ArgumentList':
            obj_ = ArgumentListType.factory()
            obj_.build(child_)
            self.set_ArgumentList(obj_)
        elif nodeName_ == 'ModLocal':
            obj_ = SideEffectListType.factory()
            obj_.build(child_)
            self.set_ModLocal(obj_)
        elif nodeName_ == 'Mod':
            obj_ = SideEffectListType.factory()
            obj_.build(child_)
            self.set_Mod(obj_)
        elif nodeName_ == 'ReadLocal':
            obj_ = SideEffectListType.factory()
            obj_.build(child_)
            self.set_ReadLocal(obj_)
        elif nodeName_ == 'Read':
            obj_ = SideEffectListType.factory()
            obj_.build(child_)
            self.set_Read(obj_)
        elif nodeName_ == 'OnEntry':
            obj_ = SideEffectListType.factory()
            obj_.build(child_)
            self.set_OnEntry(obj_)
        elif nodeName_ == 'ControlFlowVertex':
            class_obj_ = self.get_class_obj_(child_, VertexType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ControlFlowVertex.append(obj_)
        elif nodeName_ == 'BasicBlock':
            obj_ = BasicBlockType.factory()
            obj_.build(child_)
            self.ControlFlowVertex.append(obj_)
        elif nodeName_ == 'ForLoop':
            obj_ = ForLoopType.factory()
            obj_.build(child_)
            self.ControlFlowVertex.append(obj_)
        elif nodeName_ == 'PreLoop':
            obj_ = PreLoopType.factory()
            obj_.build(child_)
            self.ControlFlowVertex.append(obj_)
        elif nodeName_ == 'PostLoop':
            obj_ = PostLoopType.factory()
            obj_.build(child_)
            self.ControlFlowVertex.append(obj_)
        elif nodeName_ == 'Branch':
            obj_ = BranchType.factory()
            obj_.build(child_)
            self.ControlFlowVertex.append(obj_)
        elif nodeName_ == 'If':
            obj_ = IfType.factory()
            obj_.build(child_)
            self.ControlFlowVertex.append(obj_)
        elif nodeName_ == 'Entry':
            obj_ = EntryType.factory()
            obj_.build(child_)
            self.ControlFlowVertex.append(obj_)
        elif nodeName_ == 'EndBranch':
            obj_ = EndBranchType.factory()
            obj_.build(child_)
            self.ControlFlowVertex.append(obj_)
        elif nodeName_ == 'Goto':
            obj_ = GotoType.factory()
            obj_.build(child_)
            self.ControlFlowVertex.append(obj_)
        elif nodeName_ == 'Label':
            obj_ = LabelType.factory()
            obj_.build(child_)
            self.ControlFlowVertex.append(obj_)
        elif nodeName_ == 'EndLoop':
            obj_ = EndLoopType.factory()
            obj_.build(child_)
            self.ControlFlowVertex.append(obj_)
        elif nodeName_ == 'Exit':
            obj_ = ExitType.factory()
            obj_.build(child_)
            self.ControlFlowVertex.append(obj_)
        elif nodeName_ == 'ControlFlowEdge':
            obj_ = ControlFlowEdgeType.factory()
            obj_.build(child_)
            self.ControlFlowEdge.append(obj_)
        super(ControlFlowGraphType, self).buildChildren(child_, node, nodeName_, True)
# end class ControlFlowGraphType


class ControlFlowEdgeType(EdgeType):
    subclass = None
    superclass = EdgeType
    def __init__(self, annotation='', source=None, target=None, edge_id=None, condition_value=1, has_condition_value=False):
        super(ControlFlowEdgeType, self).__init__(annotation, source, target, edge_id, )
        self.condition_value = _cast(int, condition_value)
        self.has_condition_value = _cast(bool, has_condition_value)
        pass
    def factory(*args_, **kwargs_):
        if ControlFlowEdgeType.subclass:
            return ControlFlowEdgeType.subclass(*args_, **kwargs_)
        else:
            return ControlFlowEdgeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_condition_value(self): return self.condition_value
    def set_condition_value(self, condition_value): self.condition_value = condition_value
    def get_has_condition_value(self): return self.has_condition_value
    def set_has_condition_value(self, has_condition_value): self.has_condition_value = has_condition_value
    def export(self, outfile, level, namespace_='xaifnii:', name_='ControlFlowEdgeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ControlFlowEdgeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ControlFlowEdgeType'):
        super(ControlFlowEdgeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ControlFlowEdgeType')
        if self.condition_value is not None and 'condition_value' not in already_processed:
            already_processed.append('condition_value')
            outfile.write(' condition_value="%s"' % self.gds_format_integer(self.condition_value, input_name='condition_value'))
        if self.has_condition_value is not None and 'has_condition_value' not in already_processed:
            already_processed.append('has_condition_value')
            outfile.write(' has_condition_value="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.has_condition_value)), input_name='has_condition_value'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ControlFlowEdgeType', fromsubclass_=False):
        super(ControlFlowEdgeType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(ControlFlowEdgeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ControlFlowEdgeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.condition_value is not None and 'condition_value' not in already_processed:
            already_processed.append('condition_value')
            showIndent(outfile, level)
            outfile.write('condition_value = %d,\n' % (self.condition_value,))
        if self.has_condition_value is not None and 'has_condition_value' not in already_processed:
            already_processed.append('has_condition_value')
            showIndent(outfile, level)
            outfile.write('has_condition_value = %s,\n' % (self.has_condition_value,))
        super(ControlFlowEdgeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ControlFlowEdgeType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('condition_value', node)
        if value is not None and 'condition_value' not in already_processed:
            already_processed.append('condition_value')
            try:
                self.condition_value = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('has_condition_value', node)
        if value is not None and 'has_condition_value' not in already_processed:
            already_processed.append('has_condition_value')
            if value in ('true', '1'):
                self.has_condition_value = True
            elif value in ('false', '0'):
                self.has_condition_value = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(ControlFlowEdgeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ControlFlowEdgeType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ControlFlowEdgeType


class BasicBlockElementType(FrontEndAnnotationType):
    subclass = None
    superclass = FrontEndAnnotationType
    def __init__(self, annotation=''):
        super(BasicBlockElementType, self).__init__(annotation, )
        pass
    def factory(*args_, **kwargs_):
        if BasicBlockElementType.subclass:
            return BasicBlockElementType.subclass(*args_, **kwargs_)
        else:
            return BasicBlockElementType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='xaifnii:', name_='BasicBlockElementType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasicBlockElementType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='BasicBlockElementType'):
        super(BasicBlockElementType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BasicBlockElementType')
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='BasicBlockElementType', fromsubclass_=False):
        super(BasicBlockElementType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(BasicBlockElementType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BasicBlockElementType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(BasicBlockElementType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BasicBlockElementType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(BasicBlockElementType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BasicBlockElementType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BasicBlockElementType


class BasicBlockType(VertexType):
    """Basic blocks are sequences of assignments and subroutine calls."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', scope_id=None, Assignment=None, SubroutineCall=None, Marker=None):
        super(BasicBlockType, self).__init__(annotation, vertex_id, )
        self.scope_id = _cast(int, scope_id)
        if Assignment is None:
            self.Assignment = []
        else:
            self.Assignment = Assignment
        if SubroutineCall is None:
            self.SubroutineCall = []
        else:
            self.SubroutineCall = SubroutineCall
        if Marker is None:
            self.Marker = []
        else:
            self.Marker = Marker
    def factory(*args_, **kwargs_):
        if BasicBlockType.subclass:
            return BasicBlockType.subclass(*args_, **kwargs_)
        else:
            return BasicBlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Assignment(self): return self.Assignment
    def set_Assignment(self, Assignment): self.Assignment = Assignment
    def add_Assignment(self, value): self.Assignment.append(value)
    def insert_Assignment(self, index, value): self.Assignment[index] = value
    def get_SubroutineCall(self): return self.SubroutineCall
    def set_SubroutineCall(self, SubroutineCall): self.SubroutineCall = SubroutineCall
    def add_SubroutineCall(self, value): self.SubroutineCall.append(value)
    def insert_SubroutineCall(self, index, value): self.SubroutineCall[index] = value
    def get_Marker(self): return self.Marker
    def set_Marker(self, Marker): self.Marker = Marker
    def add_Marker(self, value): self.Marker.append(value)
    def insert_Marker(self, index, value): self.Marker[index] = value
    def get_scope_id(self): return self.scope_id
    def set_scope_id(self, scope_id): self.scope_id = scope_id
    def export(self, outfile, level, namespace_='xaifnii:', name_='BasicBlockType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasicBlockType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='BasicBlockType'):
        super(BasicBlockType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BasicBlockType')
        if self.scope_id is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            outfile.write(' scope_id="%s"' % self.gds_format_integer(self.scope_id, input_name='scope_id'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='BasicBlockType', fromsubclass_=False):
        super(BasicBlockType, self).exportChildren(outfile, level, namespace_, name_, True)
        for Assignment_ in self.Assignment:
            Assignment_.export(outfile, level, namespace_, name_='Assignment')
        for SubroutineCall_ in self.SubroutineCall:
            SubroutineCall_.export(outfile, level, namespace_, name_='SubroutineCall')
        for Marker_ in self.Marker:
            Marker_.export(outfile, level, namespace_, name_='Marker')
    def hasContent_(self):
        if (
            self.Assignment or
            self.SubroutineCall or
            self.Marker or
            super(BasicBlockType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BasicBlockType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.scope_id is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            showIndent(outfile, level)
            outfile.write('scope_id = %d,\n' % (self.scope_id,))
        super(BasicBlockType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BasicBlockType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Assignment=[\n')
        level += 1
        for Assignment_ in self.Assignment:
            showIndent(outfile, level)
            outfile.write('model_.Assignment(\n')
            Assignment_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('SubroutineCall=[\n')
        level += 1
        for SubroutineCall_ in self.SubroutineCall:
            showIndent(outfile, level)
            outfile.write('model_.SubroutineCall(\n')
            SubroutineCall_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('Marker=[\n')
        level += 1
        for Marker_ in self.Marker:
            showIndent(outfile, level)
            outfile.write('model_.Marker(\n')
            Marker_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scope_id', node)
        if value is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            try:
                self.scope_id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.scope_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        super(BasicBlockType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Assignment':
            obj_ = BasicBlockAssignmentType.factory()
            obj_.build(child_)
            self.Assignment.append(obj_)
        elif nodeName_ == 'SubroutineCall':
            obj_ = SubroutineCallType.factory()
            obj_.build(child_)
            self.SubroutineCall.append(obj_)
        elif nodeName_ == 'Marker':
            obj_ = MarkerType.factory()
            obj_.build(child_)
            self.Marker.append(obj_)
        super(BasicBlockType, self).buildChildren(child_, node, nodeName_, True)
# end class BasicBlockType


class ForLoopType(VertexType):
    """For loops with a single initialization, condition, and update."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', reversal='anonymous', lineNumber=0, Initialization=None, Condition=None, Update=None):
        super(ForLoopType, self).__init__(annotation, vertex_id, )
        self.reversal = _cast(None, reversal)
        self.lineNumber = _cast(int, lineNumber)
        self.Initialization = Initialization
        self.Condition = Condition
        self.Update = Update
    def factory(*args_, **kwargs_):
        if ForLoopType.subclass:
            return ForLoopType.subclass(*args_, **kwargs_)
        else:
            return ForLoopType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Initialization(self): return self.Initialization
    def set_Initialization(self, Initialization): self.Initialization = Initialization
    def get_Condition(self): return self.Condition
    def set_Condition(self, Condition): self.Condition = Condition
    def get_Update(self): return self.Update
    def set_Update(self, Update): self.Update = Update
    def get_reversal(self): return self.reversal
    def set_reversal(self, reversal): self.reversal = reversal
    def get_lineNumber(self): return self.lineNumber
    def set_lineNumber(self, lineNumber): self.lineNumber = lineNumber
    def export(self, outfile, level, namespace_='xaifnii:', name_='ForLoopType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ForLoopType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ForLoopType'):
        super(ForLoopType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ForLoopType')
        if self.reversal is not None and 'reversal' not in already_processed:
            already_processed.append('reversal')
            outfile.write(' reversal=%s' % (quote_attrib(self.reversal), ))
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            outfile.write(' lineNumber="%s"' % self.gds_format_integer(self.lineNumber, input_name='lineNumber'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ForLoopType', fromsubclass_=False):
        super(ForLoopType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Initialization is not None:
            self.Initialization.export(outfile, level, namespace_, name_='Initialization')
        if self.Condition is not None:
            self.Condition.export(outfile, level, namespace_, name_='Condition')
        if self.Update is not None:
            self.Update.export(outfile, level, namespace_, name_='Update')
    def hasContent_(self):
        if (
            self.Initialization is not None or
            self.Condition is not None or
            self.Update is not None or
            super(ForLoopType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ForLoopType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.reversal is not None and 'reversal' not in already_processed:
            already_processed.append('reversal')
            showIndent(outfile, level)
            outfile.write('reversal = %s,\n' % (self.reversal,))
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            showIndent(outfile, level)
            outfile.write('lineNumber = %d,\n' % (self.lineNumber,))
        super(ForLoopType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ForLoopType, self).exportLiteralChildren(outfile, level, name_)
        if self.Initialization is not None:
            showIndent(outfile, level)
            outfile.write('Initialization=model_.AssignmentType(\n')
            self.Initialization.exportLiteral(outfile, level, name_='Initialization')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Condition is not None:
            showIndent(outfile, level)
            outfile.write('Condition=model_.ExpressionType(\n')
            self.Condition.exportLiteral(outfile, level, name_='Condition')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Update is not None:
            showIndent(outfile, level)
            outfile.write('Update=model_.AssignmentType(\n')
            self.Update.exportLiteral(outfile, level, name_='Update')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('reversal', node)
        if value is not None and 'reversal' not in already_processed:
            already_processed.append('reversal')
            self.reversal = value
        value = find_attr_value_('lineNumber', node)
        if value is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            try:
                self.lineNumber = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.lineNumber < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        super(ForLoopType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Initialization':
            class_obj_ = self.get_class_obj_(child_, AssignmentType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Initialization(obj_)
        elif nodeName_ == 'Condition':
            obj_ = ExpressionType.factory()
            obj_.build(child_)
            self.set_Condition(obj_)
        elif nodeName_ == 'Update':
            class_obj_ = self.get_class_obj_(child_, AssignmentType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_Update(obj_)
        super(ForLoopType, self).buildChildren(child_, node, nodeName_, True)
# end class ForLoopType


class PreLoopType(VertexType):
    """Loops with test of condition before first execution of loop body."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', lineNumber=0, Condition=None):
        super(PreLoopType, self).__init__(annotation, vertex_id, )
        self.lineNumber = _cast(int, lineNumber)
        self.Condition = Condition
    def factory(*args_, **kwargs_):
        if PreLoopType.subclass:
            return PreLoopType.subclass(*args_, **kwargs_)
        else:
            return PreLoopType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Condition(self): return self.Condition
    def set_Condition(self, Condition): self.Condition = Condition
    def get_lineNumber(self): return self.lineNumber
    def set_lineNumber(self, lineNumber): self.lineNumber = lineNumber
    def export(self, outfile, level, namespace_='xaifnii:', name_='PreLoopType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PreLoopType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='PreLoopType'):
        super(PreLoopType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PreLoopType')
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            outfile.write(' lineNumber="%s"' % self.gds_format_integer(self.lineNumber, input_name='lineNumber'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='PreLoopType', fromsubclass_=False):
        super(PreLoopType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Condition is not None:
            self.Condition.export(outfile, level, namespace_, name_='Condition')
    def hasContent_(self):
        if (
            self.Condition is not None or
            super(PreLoopType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PreLoopType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            showIndent(outfile, level)
            outfile.write('lineNumber = %d,\n' % (self.lineNumber,))
        super(PreLoopType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PreLoopType, self).exportLiteralChildren(outfile, level, name_)
        if self.Condition is not None:
            showIndent(outfile, level)
            outfile.write('Condition=model_.ExpressionType(\n')
            self.Condition.exportLiteral(outfile, level, name_='Condition')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lineNumber', node)
        if value is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            try:
                self.lineNumber = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.lineNumber < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        super(PreLoopType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Condition':
            obj_ = ExpressionType.factory()
            obj_.build(child_)
            self.set_Condition(obj_)
        super(PreLoopType, self).buildChildren(child_, node, nodeName_, True)
# end class PreLoopType


class PostLoopType(VertexType):
    """Loops with test of condition after first execution of loop body."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', lineNumber=0, Condition=None):
        super(PostLoopType, self).__init__(annotation, vertex_id, )
        self.lineNumber = _cast(int, lineNumber)
        self.Condition = Condition
    def factory(*args_, **kwargs_):
        if PostLoopType.subclass:
            return PostLoopType.subclass(*args_, **kwargs_)
        else:
            return PostLoopType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Condition(self): return self.Condition
    def set_Condition(self, Condition): self.Condition = Condition
    def get_lineNumber(self): return self.lineNumber
    def set_lineNumber(self, lineNumber): self.lineNumber = lineNumber
    def export(self, outfile, level, namespace_='xaifnii:', name_='PostLoopType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PostLoopType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='PostLoopType'):
        super(PostLoopType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PostLoopType')
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            outfile.write(' lineNumber="%s"' % self.gds_format_integer(self.lineNumber, input_name='lineNumber'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='PostLoopType', fromsubclass_=False):
        super(PostLoopType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Condition is not None:
            self.Condition.export(outfile, level, namespace_, name_='Condition')
    def hasContent_(self):
        if (
            self.Condition is not None or
            super(PostLoopType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PostLoopType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            showIndent(outfile, level)
            outfile.write('lineNumber = %d,\n' % (self.lineNumber,))
        super(PostLoopType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PostLoopType, self).exportLiteralChildren(outfile, level, name_)
        if self.Condition is not None:
            showIndent(outfile, level)
            outfile.write('Condition=model_.ExpressionType(\n')
            self.Condition.exportLiteral(outfile, level, name_='Condition')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lineNumber', node)
        if value is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            try:
                self.lineNumber = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.lineNumber < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        super(PostLoopType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Condition':
            obj_ = ExpressionType.factory()
            obj_.build(child_)
            self.set_Condition(obj_)
        super(PostLoopType, self).buildChildren(child_, node, nodeName_, True)
# end class PostLoopType


class BranchType(VertexType):
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', lineNumber=0, Condition=None):
        super(BranchType, self).__init__(annotation, vertex_id, )
        self.lineNumber = _cast(int, lineNumber)
        self.Condition = Condition
    def factory(*args_, **kwargs_):
        if BranchType.subclass:
            return BranchType.subclass(*args_, **kwargs_)
        else:
            return BranchType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Condition(self): return self.Condition
    def set_Condition(self, Condition): self.Condition = Condition
    def get_lineNumber(self): return self.lineNumber
    def set_lineNumber(self, lineNumber): self.lineNumber = lineNumber
    def export(self, outfile, level, namespace_='xaifnii:', name_='BranchType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BranchType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='BranchType'):
        super(BranchType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BranchType')
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            outfile.write(' lineNumber="%s"' % self.gds_format_integer(self.lineNumber, input_name='lineNumber'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='BranchType', fromsubclass_=False):
        super(BranchType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Condition is not None:
            self.Condition.export(outfile, level, namespace_, name_='Condition')
    def hasContent_(self):
        if (
            self.Condition is not None or
            super(BranchType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BranchType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            showIndent(outfile, level)
            outfile.write('lineNumber = %d,\n' % (self.lineNumber,))
        super(BranchType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BranchType, self).exportLiteralChildren(outfile, level, name_)
        if self.Condition is not None:
            showIndent(outfile, level)
            outfile.write('Condition=model_.ExpressionType(\n')
            self.Condition.exportLiteral(outfile, level, name_='Condition')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lineNumber', node)
        if value is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            try:
                self.lineNumber = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.lineNumber < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        super(BranchType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Condition':
            obj_ = ExpressionType.factory()
            obj_.build(child_)
            self.set_Condition(obj_)
        super(BranchType, self).buildChildren(child_, node, nodeName_, True)
# end class BranchType


class IfType(VertexType):
    """If tests in control flow graph."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', lineNumber=0, Condition=None):
        super(IfType, self).__init__(annotation, vertex_id, )
        self.lineNumber = _cast(int, lineNumber)
        self.Condition = Condition
    def factory(*args_, **kwargs_):
        if IfType.subclass:
            return IfType.subclass(*args_, **kwargs_)
        else:
            return IfType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Condition(self): return self.Condition
    def set_Condition(self, Condition): self.Condition = Condition
    def get_lineNumber(self): return self.lineNumber
    def set_lineNumber(self, lineNumber): self.lineNumber = lineNumber
    def export(self, outfile, level, namespace_='xaifnii:', name_='IfType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IfType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='IfType'):
        super(IfType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IfType')
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            outfile.write(' lineNumber="%s"' % self.gds_format_integer(self.lineNumber, input_name='lineNumber'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='IfType', fromsubclass_=False):
        super(IfType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.Condition is not None:
            self.Condition.export(outfile, level, namespace_, name_='Condition')
    def hasContent_(self):
        if (
            self.Condition is not None or
            super(IfType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IfType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            showIndent(outfile, level)
            outfile.write('lineNumber = %d,\n' % (self.lineNumber,))
        super(IfType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IfType, self).exportLiteralChildren(outfile, level, name_)
        if self.Condition is not None:
            showIndent(outfile, level)
            outfile.write('Condition=model_.ExpressionType(\n')
            self.Condition.exportLiteral(outfile, level, name_='Condition')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lineNumber', node)
        if value is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            try:
                self.lineNumber = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.lineNumber < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        super(IfType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Condition':
            obj_ = ExpressionType.factory()
            obj_.build(child_)
            self.set_Condition(obj_)
        super(IfType, self).buildChildren(child_, node, nodeName_, True)
# end class IfType


class EntryType(VertexType):
    """Unique entry node of control flow graph."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1'):
        super(EntryType, self).__init__(annotation, vertex_id, )
        pass
    def factory(*args_, **kwargs_):
        if EntryType.subclass:
            return EntryType.subclass(*args_, **kwargs_)
        else:
            return EntryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='xaifnii:', name_='EntryType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EntryType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='EntryType'):
        super(EntryType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EntryType')
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='EntryType', fromsubclass_=False):
        super(EntryType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(EntryType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EntryType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EntryType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EntryType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EntryType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EntryType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EntryType


class EndBranchType(VertexType):
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1'):
        super(EndBranchType, self).__init__(annotation, vertex_id, )
        pass
    def factory(*args_, **kwargs_):
        if EndBranchType.subclass:
            return EndBranchType.subclass(*args_, **kwargs_)
        else:
            return EndBranchType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='xaifnii:', name_='EndBranchType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndBranchType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='EndBranchType'):
        super(EndBranchType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EndBranchType')
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='EndBranchType', fromsubclass_=False):
        super(EndBranchType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(EndBranchType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndBranchType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EndBranchType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EndBranchType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EndBranchType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EndBranchType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EndBranchType


class GotoType(VertexType):
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1'):
        super(GotoType, self).__init__(annotation, vertex_id, )
        pass
    def factory(*args_, **kwargs_):
        if GotoType.subclass:
            return GotoType.subclass(*args_, **kwargs_)
        else:
            return GotoType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='xaifnii:', name_='GotoType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GotoType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='GotoType'):
        super(GotoType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='GotoType')
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='GotoType', fromsubclass_=False):
        super(GotoType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(GotoType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='GotoType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(GotoType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(GotoType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(GotoType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(GotoType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class GotoType


class LabelType(VertexType):
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1'):
        super(LabelType, self).__init__(annotation, vertex_id, )
        pass
    def factory(*args_, **kwargs_):
        if LabelType.subclass:
            return LabelType.subclass(*args_, **kwargs_)
        else:
            return LabelType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='xaifnii:', name_='LabelType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LabelType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='LabelType'):
        super(LabelType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='LabelType')
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='LabelType', fromsubclass_=False):
        super(LabelType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(LabelType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='LabelType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(LabelType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(LabelType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(LabelType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(LabelType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class LabelType


class EndLoopType(VertexType):
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1'):
        super(EndLoopType, self).__init__(annotation, vertex_id, )
        pass
    def factory(*args_, **kwargs_):
        if EndLoopType.subclass:
            return EndLoopType.subclass(*args_, **kwargs_)
        else:
            return EndLoopType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='xaifnii:', name_='EndLoopType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EndLoopType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='EndLoopType'):
        super(EndLoopType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EndLoopType')
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='EndLoopType', fromsubclass_=False):
        super(EndLoopType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(EndLoopType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='EndLoopType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EndLoopType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EndLoopType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(EndLoopType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EndLoopType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EndLoopType


class ExitType(VertexType):
    """Unique exit node in control flow graph."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1'):
        super(ExitType, self).__init__(annotation, vertex_id, )
        pass
    def factory(*args_, **kwargs_):
        if ExitType.subclass:
            return ExitType.subclass(*args_, **kwargs_)
        else:
            return ExitType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def export(self, outfile, level, namespace_='xaifnii:', name_='ExitType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExitType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ExitType'):
        super(ExitType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExitType')
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ExitType', fromsubclass_=False):
        super(ExitType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(ExitType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExitType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ExitType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ExitType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ExitType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ExitType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExitType


class AssignmentBaseType(GeneratedsSuper):
    """Assignments consist of a variable reference on the lhs and an
    expression on the rhs. Within the current basic block they are
    uniquely identified by their statement_id."""
    subclass = None
    superclass = None
    def __init__(self, AssignmentLHS=None, AssignmentRHS=None, extensiontype_=None):
        self.AssignmentLHS = AssignmentLHS
        self.AssignmentRHS = AssignmentRHS
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AssignmentBaseType.subclass:
            return AssignmentBaseType.subclass(*args_, **kwargs_)
        else:
            return AssignmentBaseType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_AssignmentLHS(self): return self.AssignmentLHS
    def set_AssignmentLHS(self, AssignmentLHS): self.AssignmentLHS = AssignmentLHS
    def get_AssignmentRHS(self): return self.AssignmentRHS
    def set_AssignmentRHS(self, AssignmentRHS): self.AssignmentRHS = AssignmentRHS
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xaifnii:', name_='AssignmentBaseType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssignmentBaseType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='AssignmentBaseType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='AssignmentBaseType', fromsubclass_=False):
        if self.AssignmentLHS is not None:
            self.AssignmentLHS.export(outfile, level, namespace_, name_='AssignmentLHS', )
        if self.AssignmentRHS is not None:
            self.AssignmentRHS.export(outfile, level, namespace_, name_='AssignmentRHS', )
    def hasContent_(self):
        if (
            self.AssignmentLHS is not None or
            self.AssignmentRHS is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssignmentBaseType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.AssignmentLHS is not None:
            showIndent(outfile, level)
            outfile.write('AssignmentLHS=model_.AssignmentLHSType(\n')
            self.AssignmentLHS.exportLiteral(outfile, level, name_='AssignmentLHS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.AssignmentRHS is not None:
            showIndent(outfile, level)
            outfile.write('AssignmentRHS=model_.ExpressionType(\n')
            self.AssignmentRHS.exportLiteral(outfile, level, name_='AssignmentRHS')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'AssignmentLHS':
            obj_ = AssignmentLHSType.factory()
            obj_.build(child_)
            self.set_AssignmentLHS(obj_)
        elif nodeName_ == 'AssignmentRHS':
            obj_ = ExpressionType.factory()
            obj_.build(child_)
            self.set_AssignmentRHS(obj_)
# end class AssignmentBaseType


class AssignmentType(AssignmentBaseType):
    """Key into DOSet for a chain of statements overwriting the LHS of this
    assignment. Note, there is no placeholder for the LHS going out
    of scope (and subsequent overwrite by reuse)"""
    subclass = None
    superclass = AssignmentBaseType
    def __init__(self, AssignmentLHS=None, AssignmentRHS=None, statement_id=None, do_chain=0, extensiontype_=None):
        super(AssignmentType, self).__init__(AssignmentLHS, AssignmentRHS, extensiontype_, )
        self.statement_id = _cast(None, statement_id)
        self.do_chain = _cast(int, do_chain)
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if AssignmentType.subclass:
            return AssignmentType.subclass(*args_, **kwargs_)
        else:
            return AssignmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_statement_id(self): return self.statement_id
    def set_statement_id(self, statement_id): self.statement_id = statement_id
    def get_do_chain(self): return self.do_chain
    def set_do_chain(self, do_chain): self.do_chain = do_chain
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xaifnii:', name_='AssignmentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssignmentType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='AssignmentType'):
        super(AssignmentType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssignmentType')
        if self.statement_id is not None and 'statement_id' not in already_processed:
            already_processed.append('statement_id')
            outfile.write(' statement_id=%s' % (self.gds_format_string(quote_attrib(self.statement_id).encode(ExternalEncoding), input_name='statement_id'), ))
        if self.do_chain is not None and 'do_chain' not in already_processed:
            already_processed.append('do_chain')
            outfile.write(' do_chain="%s"' % self.gds_format_integer(self.do_chain, input_name='do_chain'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='AssignmentType', fromsubclass_=False):
        super(AssignmentType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AssignmentType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssignmentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.statement_id is not None and 'statement_id' not in already_processed:
            already_processed.append('statement_id')
            showIndent(outfile, level)
            outfile.write('statement_id = "%s",\n' % (self.statement_id,))
        if self.do_chain is not None and 'do_chain' not in already_processed:
            already_processed.append('do_chain')
            showIndent(outfile, level)
            outfile.write('do_chain = %d,\n' % (self.do_chain,))
        super(AssignmentType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AssignmentType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('statement_id', node)
        if value is not None and 'statement_id' not in already_processed:
            already_processed.append('statement_id')
            self.statement_id = value
        value = find_attr_value_('do_chain', node)
        if value is not None and 'do_chain' not in already_processed:
            already_processed.append('do_chain')
            try:
                self.do_chain = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(AssignmentType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AssignmentType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AssignmentType


class BasicBlockAssignmentType(AssignmentType):
    subclass = None
    superclass = AssignmentType
    def __init__(self, AssignmentLHS=None, AssignmentRHS=None, statement_id=None, do_chain=0, lineNumber=0):
        super(BasicBlockAssignmentType, self).__init__(AssignmentLHS, AssignmentRHS, statement_id, do_chain, )
        self.lineNumber = _cast(int, lineNumber)
        pass
    def factory(*args_, **kwargs_):
        if BasicBlockAssignmentType.subclass:
            return BasicBlockAssignmentType.subclass(*args_, **kwargs_)
        else:
            return BasicBlockAssignmentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_lineNumber(self): return self.lineNumber
    def set_lineNumber(self, lineNumber): self.lineNumber = lineNumber
    def export(self, outfile, level, namespace_='xaifnii:', name_='BasicBlockAssignmentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BasicBlockAssignmentType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='BasicBlockAssignmentType'):
        super(BasicBlockAssignmentType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BasicBlockAssignmentType')
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            outfile.write(' lineNumber="%s"' % self.gds_format_integer(self.lineNumber, input_name='lineNumber'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='BasicBlockAssignmentType', fromsubclass_=False):
        super(BasicBlockAssignmentType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(BasicBlockAssignmentType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BasicBlockAssignmentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            showIndent(outfile, level)
            outfile.write('lineNumber = %d,\n' % (self.lineNumber,))
        super(BasicBlockAssignmentType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BasicBlockAssignmentType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('lineNumber', node)
        if value is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            try:
                self.lineNumber = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.lineNumber < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        super(BasicBlockAssignmentType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BasicBlockAssignmentType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BasicBlockAssignmentType


class ExpressionEdgeType(EdgeType):
    subclass = None
    superclass = EdgeType
    def __init__(self, annotation='', source=None, target=None, edge_id=None, position=None):
        super(ExpressionEdgeType, self).__init__(annotation, source, target, edge_id, )
        self.position = _cast(int, position)
        pass
    def factory(*args_, **kwargs_):
        if ExpressionEdgeType.subclass:
            return ExpressionEdgeType.subclass(*args_, **kwargs_)
        else:
            return ExpressionEdgeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def export(self, outfile, level, namespace_='xaifnii:', name_='ExpressionEdgeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExpressionEdgeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ExpressionEdgeType'):
        super(ExpressionEdgeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExpressionEdgeType')
        if self.position is not None and 'position' not in already_processed:
            already_processed.append('position')
            outfile.write(' position="%s"' % self.gds_format_integer(self.position, input_name='position'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ExpressionEdgeType', fromsubclass_=False):
        super(ExpressionEdgeType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(ExpressionEdgeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExpressionEdgeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.position is not None and 'position' not in already_processed:
            already_processed.append('position')
            showIndent(outfile, level)
            outfile.write('position = %d,\n' % (self.position,))
        super(ExpressionEdgeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ExpressionEdgeType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.append('position')
            try:
                self.position = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        super(ExpressionEdgeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ExpressionEdgeType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ExpressionEdgeType


class ExpressionType(GeneratedsSuper):
    """Expressions are dag's in the classical compiler sense."""
    subclass = None
    superclass = None
    def __init__(self, ExpressionVertex=None, ExpressionEdge=None):
        if ExpressionVertex is None:
            self.ExpressionVertex = []
        else:
            self.ExpressionVertex = ExpressionVertex
        if ExpressionEdge is None:
            self.ExpressionEdge = []
        else:
            self.ExpressionEdge = ExpressionEdge
    def factory(*args_, **kwargs_):
        if ExpressionType.subclass:
            return ExpressionType.subclass(*args_, **kwargs_)
        else:
            return ExpressionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ExpressionVertex(self): return self.ExpressionVertex
    def set_ExpressionVertex(self, ExpressionVertex): self.ExpressionVertex = ExpressionVertex
    def add_ExpressionVertex(self, value): self.ExpressionVertex.append(value)
    def insert_ExpressionVertex(self, index, value): self.ExpressionVertex[index] = value
    def get_ExpressionEdge(self): return self.ExpressionEdge
    def set_ExpressionEdge(self, ExpressionEdge): self.ExpressionEdge = ExpressionEdge
    def add_ExpressionEdge(self, value): self.ExpressionEdge.append(value)
    def insert_ExpressionEdge(self, index, value): self.ExpressionEdge[index] = value
    def export(self, outfile, level, namespace_='xaifnii:', name_='ExpressionType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExpressionType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ExpressionType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ExpressionType', fromsubclass_=False):
        for ExpressionVertex_ in self.ExpressionVertex:
            ExpressionVertex_.export(outfile, level, namespace_, name_='ExpressionVertex')
        for ExpressionEdge_ in self.ExpressionEdge:
            ExpressionEdge_.export(outfile, level, namespace_, name_='ExpressionEdge')
    def hasContent_(self):
        if (
            self.ExpressionVertex or
            self.ExpressionEdge
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ExpressionType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('ExpressionVertex=[\n')
        level += 1
        for ExpressionVertex_ in self.ExpressionVertex:
            showIndent(outfile, level)
            outfile.write('model_.ExpressionVertex(\n')
            ExpressionVertex_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('ExpressionEdge=[\n')
        level += 1
        for ExpressionEdge_ in self.ExpressionEdge:
            showIndent(outfile, level)
            outfile.write('model_.ExpressionEdgeType(\n')
            ExpressionEdge_.exportLiteral(outfile, level, name_='ExpressionEdgeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ExpressionVertex':
            class_obj_ = self.get_class_obj_(child_, VertexType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ExpressionVertex.append(obj_)
        elif nodeName_ == 'VariableReference':
            class_obj_ = self.get_class_obj_(child_, VariableReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.ExpressionVertex.append(obj_)
        elif nodeName_ == 'Intrinsic':
            obj_ = IntrinsicType.factory()
            obj_.build(child_)
            self.ExpressionVertex.append(obj_)
        elif nodeName_ == 'BooleanOperation':
            obj_ = BooleanOperationType.factory()
            obj_.build(child_)
            self.ExpressionVertex.append(obj_)
        elif nodeName_ == 'Constant':
            obj_ = ConstantType.factory()
            obj_.build(child_)
            self.ExpressionVertex.append(obj_)
        elif nodeName_ == 'FunctionCall':
            obj_ = FunctionCallType.factory()
            obj_.build(child_)
            self.ExpressionVertex.append(obj_)
        elif nodeName_ == 'ExpressionEdge':
            obj_ = ExpressionEdgeType.factory()
            obj_.build(child_)
            self.ExpressionEdge.append(obj_)
# end class ExpressionType


class SubroutineArgumentType(FrontEndAnnotationType):
    """An argument may either be a single variable or a single constant.
    More complex expressions are supposed to be hoisted by
    canonicalization. To cover possible optional arguments we
    identify each actual argument by its respective position in the
    formal (ordered) argument list. The position must be greater
    than 0 and less than or equal SubroutineCallType:formalArgCount"""
    subclass = None
    superclass = FrontEndAnnotationType
    def __init__(self, annotation='', position=None, VariableReference=None, Constant=None):
        super(SubroutineArgumentType, self).__init__(annotation, )
        self.position = _cast(int, position)
        self.VariableReference = VariableReference
        self.Constant = Constant
    def factory(*args_, **kwargs_):
        if SubroutineArgumentType.subclass:
            return SubroutineArgumentType.subclass(*args_, **kwargs_)
        else:
            return SubroutineArgumentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VariableReference(self): return self.VariableReference
    def set_VariableReference(self, VariableReference): self.VariableReference = VariableReference
    def get_Constant(self): return self.Constant
    def set_Constant(self, Constant): self.Constant = Constant
    def get_position(self): return self.position
    def set_position(self, position): self.position = position
    def export(self, outfile, level, namespace_='xaifnii:', name_='SubroutineArgumentType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubroutineArgumentType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='SubroutineArgumentType'):
        super(SubroutineArgumentType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SubroutineArgumentType')
        if self.position is not None and 'position' not in already_processed:
            already_processed.append('position')
            outfile.write(' position="%s"' % self.gds_format_integer(self.position, input_name='position'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='SubroutineArgumentType', fromsubclass_=False):
        super(SubroutineArgumentType, self).exportChildren(outfile, level, namespace_, name_, True)
        if self.VariableReference is not None:
            self.VariableReference.export(outfile, level, namespace_, name_='VariableReference')
        if self.Constant is not None:
            self.Constant.export(outfile, level, namespace_, name_='Constant')
    def hasContent_(self):
        if (
            self.VariableReference is not None or
            self.Constant is not None or
            super(SubroutineArgumentType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubroutineArgumentType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.position is not None and 'position' not in already_processed:
            already_processed.append('position')
            showIndent(outfile, level)
            outfile.write('position = %d,\n' % (self.position,))
        super(SubroutineArgumentType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SubroutineArgumentType, self).exportLiteralChildren(outfile, level, name_)
        if self.VariableReference is not None:
            showIndent(outfile, level)
            outfile.write('VariableReference=model_.VariableReferenceType(\n')
            self.VariableReference.exportLiteral(outfile, level, name_='VariableReference')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Constant is not None:
            showIndent(outfile, level)
            outfile.write('Constant=model_.ConstantType(\n')
            self.Constant.exportLiteral(outfile, level, name_='Constant')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('position', node)
        if value is not None and 'position' not in already_processed:
            already_processed.append('position')
            try:
                self.position = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.position <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        super(SubroutineArgumentType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VariableReference':
            class_obj_ = self.get_class_obj_(child_, VariableReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.set_VariableReference(obj_)
        elif nodeName_ == 'Constant':
            obj_ = ConstantType.factory()
            obj_.build(child_)
            self.set_Constant(obj_)
        super(SubroutineArgumentType, self).buildChildren(child_, node, nodeName_, True)
# end class SubroutineArgumentType


class SubroutineCallType(GeneratedsSuper):
    """Subroutine calls appear in basic blocks together with assignments.
    They are equivalent to void functions in C/C++ or explicitly
    CALLed subroutines in Fortran. They may have arguments in the
    form of variable references. The subroutine call is identified
    uniquely by the statement_id within the current basic block, the
    symbol_id of its name within the corresponding symbol table. The
    number of formal arguments including optional ones that are not
    present in this call Therefore the number of actual arguments
    (i.e. Argument elements) may be less."""
    subclass = None
    superclass = None
    def __init__(self, statement_id=None, formalArgCount=None, scope_id=None, lineNumber=0, active='undefined', symbol_id=None, Argument=None):
        self.statement_id = _cast(None, statement_id)
        self.formalArgCount = _cast(int, formalArgCount)
        self.scope_id = _cast(int, scope_id)
        self.lineNumber = _cast(int, lineNumber)
        self.active = _cast(None, active)
        self.symbol_id = _cast(None, symbol_id)
        if Argument is None:
            self.Argument = []
        else:
            self.Argument = Argument
    def factory(*args_, **kwargs_):
        if SubroutineCallType.subclass:
            return SubroutineCallType.subclass(*args_, **kwargs_)
        else:
            return SubroutineCallType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Argument(self): return self.Argument
    def set_Argument(self, Argument): self.Argument = Argument
    def add_Argument(self, value): self.Argument.append(value)
    def insert_Argument(self, index, value): self.Argument[index] = value
    def get_statement_id(self): return self.statement_id
    def set_statement_id(self, statement_id): self.statement_id = statement_id
    def get_formalArgCount(self): return self.formalArgCount
    def set_formalArgCount(self, formalArgCount): self.formalArgCount = formalArgCount
    def get_scope_id(self): return self.scope_id
    def set_scope_id(self, scope_id): self.scope_id = scope_id
    def get_lineNumber(self): return self.lineNumber
    def set_lineNumber(self, lineNumber): self.lineNumber = lineNumber
    def get_active(self): return self.active
    def set_active(self, active): self.active = active
    def get_symbol_id(self): return self.symbol_id
    def set_symbol_id(self, symbol_id): self.symbol_id = symbol_id
    def export(self, outfile, level, namespace_='xaifnii:', name_='SubroutineCallType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SubroutineCallType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='SubroutineCallType'):
        if self.statement_id is not None and 'statement_id' not in already_processed:
            already_processed.append('statement_id')
            outfile.write(' statement_id=%s' % (self.gds_format_string(quote_attrib(self.statement_id).encode(ExternalEncoding), input_name='statement_id'), ))
        if self.formalArgCount is not None and 'formalArgCount' not in already_processed:
            already_processed.append('formalArgCount')
            outfile.write(' formalArgCount="%s"' % self.gds_format_integer(self.formalArgCount, input_name='formalArgCount'))
        if self.scope_id is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            outfile.write(' scope_id="%s"' % self.gds_format_integer(self.scope_id, input_name='scope_id'))
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            outfile.write(' lineNumber="%s"' % self.gds_format_integer(self.lineNumber, input_name='lineNumber'))
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            outfile.write(' active=%s' % (quote_attrib(self.active), ))
        if self.symbol_id is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            outfile.write(' symbol_id=%s' % (self.gds_format_string(quote_attrib(self.symbol_id).encode(ExternalEncoding), input_name='symbol_id'), ))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='SubroutineCallType', fromsubclass_=False):
        for Argument_ in self.Argument:
            Argument_.export(outfile, level, namespace_, name_='Argument')
    def hasContent_(self):
        if (
            self.Argument
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SubroutineCallType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.statement_id is not None and 'statement_id' not in already_processed:
            already_processed.append('statement_id')
            showIndent(outfile, level)
            outfile.write('statement_id = "%s",\n' % (self.statement_id,))
        if self.formalArgCount is not None and 'formalArgCount' not in already_processed:
            already_processed.append('formalArgCount')
            showIndent(outfile, level)
            outfile.write('formalArgCount = %d,\n' % (self.formalArgCount,))
        if self.scope_id is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            showIndent(outfile, level)
            outfile.write('scope_id = %d,\n' % (self.scope_id,))
        if self.lineNumber is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            showIndent(outfile, level)
            outfile.write('lineNumber = %d,\n' % (self.lineNumber,))
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            showIndent(outfile, level)
            outfile.write('active = %s,\n' % (self.active,))
        if self.symbol_id is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            showIndent(outfile, level)
            outfile.write('symbol_id = "%s",\n' % (self.symbol_id,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Argument=[\n')
        level += 1
        for Argument_ in self.Argument:
            showIndent(outfile, level)
            outfile.write('model_.SubroutineArgumentType(\n')
            Argument_.exportLiteral(outfile, level, name_='SubroutineArgumentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('statement_id', node)
        if value is not None and 'statement_id' not in already_processed:
            already_processed.append('statement_id')
            self.statement_id = value
        value = find_attr_value_('formalArgCount', node)
        if value is not None and 'formalArgCount' not in already_processed:
            already_processed.append('formalArgCount')
            try:
                self.formalArgCount = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.formalArgCount < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('scope_id', node)
        if value is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            try:
                self.scope_id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.scope_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('lineNumber', node)
        if value is not None and 'lineNumber' not in already_processed:
            already_processed.append('lineNumber')
            try:
                self.lineNumber = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.lineNumber < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('active', node)
        if value is not None and 'active' not in already_processed:
            already_processed.append('active')
            self.active = value
        value = find_attr_value_('symbol_id', node)
        if value is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            self.symbol_id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Argument':
            obj_ = SubroutineArgumentType.factory()
            obj_.build(child_)
            self.Argument.append(obj_)
# end class SubroutineCallType


class MarkerType(FrontEndAnnotationType):
    subclass = None
    superclass = FrontEndAnnotationType
    def __init__(self, annotation='', statement_id=None):
        super(MarkerType, self).__init__(annotation, )
        self.statement_id = _cast(None, statement_id)
        pass
    def factory(*args_, **kwargs_):
        if MarkerType.subclass:
            return MarkerType.subclass(*args_, **kwargs_)
        else:
            return MarkerType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_statement_id(self): return self.statement_id
    def set_statement_id(self, statement_id): self.statement_id = statement_id
    def export(self, outfile, level, namespace_='xaifnii:', name_='MarkerType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='MarkerType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='MarkerType'):
        super(MarkerType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='MarkerType')
        if self.statement_id is not None and 'statement_id' not in already_processed:
            already_processed.append('statement_id')
            outfile.write(' statement_id=%s' % (self.gds_format_string(quote_attrib(self.statement_id).encode(ExternalEncoding), input_name='statement_id'), ))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='MarkerType', fromsubclass_=False):
        super(MarkerType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(MarkerType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='MarkerType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.statement_id is not None and 'statement_id' not in already_processed:
            already_processed.append('statement_id')
            showIndent(outfile, level)
            outfile.write('statement_id = "%s",\n' % (self.statement_id,))
        super(MarkerType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(MarkerType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('statement_id', node)
        if value is not None and 'statement_id' not in already_processed:
            already_processed.append('statement_id')
            self.statement_id = value
        super(MarkerType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(MarkerType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class MarkerType


class VariableReferenceType(VertexType):
    """Variable references are in essence representing expressions for
    address computations. The front-end uses constant propagation
    analysis to determine which variable uses have a value that is a
    unique literal constant in which case the flag is set to 'true'.
    This allows to determine cases of constant use for variables
    with non-constant type and distinguishes the case of variables
    with constant type but non-literal initialization (e.g.
    initialization from a subroutine parameter)."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', active='undefined', alias=0, du_ud=0, constant=False, deriv=False, VariableReferenceVertex=None, VariableReferenceEdge=None, extensiontype_=None):
        super(VariableReferenceType, self).__init__(annotation, vertex_id, extensiontype_, )
        self.active = _cast(None, active)
        self.alias = _cast(int, alias)
        self.du_ud = _cast(int, du_ud)
        self.constant = _cast(bool, constant)
        self.deriv = _cast(bool, deriv)
        if VariableReferenceVertex is None:
            self.VariableReferenceVertex = []
        else:
            self.VariableReferenceVertex = VariableReferenceVertex
        if VariableReferenceEdge is None:
            self.VariableReferenceEdge = []
        else:
            self.VariableReferenceEdge = VariableReferenceEdge
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if VariableReferenceType.subclass:
            return VariableReferenceType.subclass(*args_, **kwargs_)
        else:
            return VariableReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_VariableReferenceVertex(self): return self.VariableReferenceVertex
    def set_VariableReferenceVertex(self, VariableReferenceVertex): self.VariableReferenceVertex = VariableReferenceVertex
    def add_VariableReferenceVertex(self, value): self.VariableReferenceVertex.append(value)
    def insert_VariableReferenceVertex(self, index, value): self.VariableReferenceVertex[index] = value
    def get_VariableReferenceEdge(self): return self.VariableReferenceEdge
    def set_VariableReferenceEdge(self, VariableReferenceEdge): self.VariableReferenceEdge = VariableReferenceEdge
    def add_VariableReferenceEdge(self, value): self.VariableReferenceEdge.append(value)
    def insert_VariableReferenceEdge(self, index, value): self.VariableReferenceEdge[index] = value
    def get_active(self): return self.active
    def set_active(self, active): self.active = active
    def get_alias(self): return self.alias
    def set_alias(self, alias): self.alias = alias
    def get_du_ud(self): return self.du_ud
    def set_du_ud(self, du_ud): self.du_ud = du_ud
    def get_constant(self): return self.constant
    def set_constant(self, constant): self.constant = constant
    def get_deriv(self): return self.deriv
    def set_deriv(self, deriv): self.deriv = deriv
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def export(self, outfile, level, namespace_='xaifnii:', name_='VariableReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='VariableReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='VariableReferenceType'):
        super(VariableReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='VariableReferenceType')
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            outfile.write(' active=%s' % (quote_attrib(self.active), ))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.append('alias')
            outfile.write(' alias="%s"' % self.gds_format_integer(self.alias, input_name='alias'))
        if self.du_ud is not None and 'du_ud' not in already_processed:
            already_processed.append('du_ud')
            outfile.write(' du_ud="%s"' % self.gds_format_integer(self.du_ud, input_name='du_ud'))
        if self.constant is not None and 'constant' not in already_processed:
            already_processed.append('constant')
            outfile.write(' constant="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.constant)), input_name='constant'))
        if self.deriv is not None and 'deriv' not in already_processed:
            already_processed.append('deriv')
            outfile.write(' deriv="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.deriv)), input_name='deriv'))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='VariableReferenceType', fromsubclass_=False):
        super(VariableReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        for VariableReferenceVertex_ in self.get_VariableReferenceVertex():
            VariableReferenceVertex_.export(outfile, level, namespace_, name_='VariableReferenceVertex')
        for VariableReferenceEdge_ in self.VariableReferenceEdge:
            VariableReferenceEdge_.export(outfile, level, namespace_, name_='VariableReferenceEdge')
    def hasContent_(self):
        if (
            self.VariableReferenceVertex or
            self.VariableReferenceEdge or
            super(VariableReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='VariableReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.active is not None and 'active' not in already_processed:
            already_processed.append('active')
            showIndent(outfile, level)
            outfile.write('active = %s,\n' % (self.active,))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.append('alias')
            showIndent(outfile, level)
            outfile.write('alias = %d,\n' % (self.alias,))
        if self.du_ud is not None and 'du_ud' not in already_processed:
            already_processed.append('du_ud')
            showIndent(outfile, level)
            outfile.write('du_ud = %d,\n' % (self.du_ud,))
        if self.constant is not None and 'constant' not in already_processed:
            already_processed.append('constant')
            showIndent(outfile, level)
            outfile.write('constant = %s,\n' % (self.constant,))
        if self.deriv is not None and 'deriv' not in already_processed:
            already_processed.append('deriv')
            showIndent(outfile, level)
            outfile.write('deriv = %s,\n' % (self.deriv,))
        super(VariableReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(VariableReferenceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('VariableReferenceVertex=[\n')
        level += 1
        for VariableReferenceVertex_ in self.VariableReferenceVertex:
            showIndent(outfile, level)
            outfile.write('model_.VariableReferenceVertex(\n')
            VariableReferenceVertex_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('VariableReferenceEdge=[\n')
        level += 1
        for VariableReferenceEdge_ in self.VariableReferenceEdge:
            showIndent(outfile, level)
            outfile.write('model_.EdgeType(\n')
            VariableReferenceEdge_.exportLiteral(outfile, level, name_='EdgeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('active', node)
        if value is not None and 'active' not in already_processed:
            already_processed.append('active')
            self.active = value
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.append('alias')
            try:
                self.alias = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('du_ud', node)
        if value is not None and 'du_ud' not in already_processed:
            already_processed.append('du_ud')
            try:
                self.du_ud = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('constant', node)
        if value is not None and 'constant' not in already_processed:
            already_processed.append('constant')
            if value in ('true', '1'):
                self.constant = True
            elif value in ('false', '0'):
                self.constant = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('deriv', node)
        if value is not None and 'deriv' not in already_processed:
            already_processed.append('deriv')
            if value in ('true', '1'):
                self.deriv = True
            elif value in ('false', '0'):
                self.deriv = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.append('xsi:type')
            self.extensiontype_ = value
        super(VariableReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'VariableReferenceVertex':
            type_name_ = child_.attrib.get('{http://www.w3.org/2001/XMLSchema-instance}type')
            if type_name_ is None:
                type_name_ = child_.attrib.get('type')
            if type_name_ is not None:
                type_names_ = type_name_.split(':')
                if len(type_names_) == 1:
                    type_name_ = type_names_[0]
                else:
                    type_name_ = type_names_[1]
                class_ = globals()[type_name_]
                obj_ = class_.factory()
                obj_.build(child_)
            else:
                raise NotImplementedError(
                    'Class not implemented for <VariableReferenceVertex> element')
            self.VariableReferenceVertex.append(obj_)
        elif nodeName_ == 'SymbolReference':
            obj_ = SymbolReferenceType.factory()
            obj_.build(child_)
            self.VariableReferenceVertex.append(obj_)
        elif nodeName_ == 'ArrayElementReference':
            obj_ = ArrayElementReferenceType.factory()
            obj_.build(child_)
            self.VariableReferenceVertex.append(obj_)
        elif nodeName_ == 'VariableReferenceEdge':
            class_obj_ = self.get_class_obj_(child_, EdgeType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.VariableReferenceEdge.append(obj_)
        super(VariableReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class VariableReferenceType


class IntrinsicType(VertexType):
    """Operations are intrinsic if derivative code is available for them.
    The type of the intrinsic return value The shape of the
    intrinsic return value"""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', rShape='scalar', type_='inlinable', name=None, rType='real'):
        super(IntrinsicType, self).__init__(annotation, vertex_id, )
        self.rShape = _cast(None, rShape)
        self.type_ = _cast(None, type_)
        self.name = _cast(None, name)
        self.rType = _cast(None, rType)
        pass
    def factory(*args_, **kwargs_):
        if IntrinsicType.subclass:
            return IntrinsicType.subclass(*args_, **kwargs_)
        else:
            return IntrinsicType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_rShape(self): return self.rShape
    def set_rShape(self, rShape): self.rShape = rShape
    def validate_SymbolShapeType(self, value):
        # Validate type SymbolShapeType, a restriction on xsd:string.
        pass
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_rType(self): return self.rType
    def set_rType(self, rType): self.rType = rType
    def validate_SymbolTypeType(self, value):
        # Validate type SymbolTypeType, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='xaifnii:', name_='IntrinsicType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IntrinsicType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='IntrinsicType'):
        super(IntrinsicType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='IntrinsicType')
        if self.rShape is not None and 'rShape' not in already_processed:
            already_processed.append('rShape')
            outfile.write(' rShape=%s' % (quote_attrib(self.rShape), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.rType is not None and 'rType' not in already_processed:
            already_processed.append('rType')
            outfile.write(' rType=%s' % (quote_attrib(self.rType), ))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='IntrinsicType', fromsubclass_=False):
        super(IntrinsicType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(IntrinsicType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IntrinsicType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.rShape is not None and 'rShape' not in already_processed:
            already_processed.append('rShape')
            showIndent(outfile, level)
            outfile.write('rShape = "%s",\n' % (self.rShape,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.rType is not None and 'rType' not in already_processed:
            already_processed.append('rType')
            showIndent(outfile, level)
            outfile.write('rType = "%s",\n' % (self.rType,))
        super(IntrinsicType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(IntrinsicType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('rShape', node)
        if value is not None and 'rShape' not in already_processed:
            already_processed.append('rShape')
            self.rShape = value
            self.validate_SymbolShapeType(self.rShape)    # validate type SymbolShapeType
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('rType', node)
        if value is not None and 'rType' not in already_processed:
            already_processed.append('rType')
            self.rType = value
            self.validate_SymbolTypeType(self.rType)    # validate type SymbolTypeType
        super(IntrinsicType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(IntrinsicType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class IntrinsicType


class BooleanOperationType(VertexType):
    """Boolean operations that are built into XAIF."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', name=None):
        super(BooleanOperationType, self).__init__(annotation, vertex_id, )
        self.name = _cast(None, name)
        pass
    def factory(*args_, **kwargs_):
        if BooleanOperationType.subclass:
            return BooleanOperationType.subclass(*args_, **kwargs_)
        else:
            return BooleanOperationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def validate_BuiltinBooleanOperations(self, value):
        # Validate type BuiltinBooleanOperations, a restriction on xsd:string.
        pass
    def export(self, outfile, level, namespace_='xaifnii:', name_='BooleanOperationType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BooleanOperationType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='BooleanOperationType'):
        super(BooleanOperationType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='BooleanOperationType')
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (quote_attrib(self.name), ))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='BooleanOperationType', fromsubclass_=False):
        super(BooleanOperationType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(BooleanOperationType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='BooleanOperationType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        super(BooleanOperationType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(BooleanOperationType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
            self.validate_BuiltinBooleanOperations(self.name)    # validate type BuiltinBooleanOperations
        super(BooleanOperationType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(BooleanOperationType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class BooleanOperationType


class SymbolReferencePropertyType(GeneratedsSuper):
    """A name-value pair for arbitrary symbol reference properties."""
    subclass = None
    superclass = None
    def __init__(self, name=None, value=None):
        self.name = _cast(None, name)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if SymbolReferencePropertyType.subclass:
            return SymbolReferencePropertyType.subclass(*args_, **kwargs_)
        else:
            return SymbolReferencePropertyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='xaifnii:', name_='SymbolReferencePropertyType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SymbolReferencePropertyType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='SymbolReferencePropertyType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='SymbolReferencePropertyType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SymbolReferencePropertyType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.append('name')
            showIndent(outfile, level)
            outfile.write('name = "%s",\n' % (self.name,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.append('name')
            self.name = value
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SymbolReferencePropertyType


class SymbolReferenceType(VertexType):
    """A symbol is referenced uniquely by its id inside a given scope."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', scope_id=None, symbol_id=None, SymbolReferenceProperty=None):
        super(SymbolReferenceType, self).__init__(annotation, vertex_id, )
        self.scope_id = _cast(int, scope_id)
        self.symbol_id = _cast(None, symbol_id)
        if SymbolReferenceProperty is None:
            self.SymbolReferenceProperty = []
        else:
            self.SymbolReferenceProperty = SymbolReferenceProperty
    def factory(*args_, **kwargs_):
        if SymbolReferenceType.subclass:
            return SymbolReferenceType.subclass(*args_, **kwargs_)
        else:
            return SymbolReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SymbolReferenceProperty(self): return self.SymbolReferenceProperty
    def set_SymbolReferenceProperty(self, SymbolReferenceProperty): self.SymbolReferenceProperty = SymbolReferenceProperty
    def add_SymbolReferenceProperty(self, value): self.SymbolReferenceProperty.append(value)
    def insert_SymbolReferenceProperty(self, index, value): self.SymbolReferenceProperty[index] = value
    def get_scope_id(self): return self.scope_id
    def set_scope_id(self, scope_id): self.scope_id = scope_id
    def get_symbol_id(self): return self.symbol_id
    def set_symbol_id(self, symbol_id): self.symbol_id = symbol_id
    def export(self, outfile, level, namespace_='xaifnii:', name_='SymbolReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SymbolReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='SymbolReferenceType'):
        super(SymbolReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SymbolReferenceType')
        if self.scope_id is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            outfile.write(' scope_id="%s"' % self.gds_format_integer(self.scope_id, input_name='scope_id'))
        if self.symbol_id is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            outfile.write(' symbol_id=%s' % (self.gds_format_string(quote_attrib(self.symbol_id).encode(ExternalEncoding), input_name='symbol_id'), ))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='SymbolReferenceType', fromsubclass_=False):
        super(SymbolReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        for SymbolReferenceProperty_ in self.SymbolReferenceProperty:
            SymbolReferenceProperty_.export(outfile, level, namespace_, name_='SymbolReferenceProperty')
    def hasContent_(self):
        if (
            self.SymbolReferenceProperty or
            super(SymbolReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='SymbolReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.scope_id is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            showIndent(outfile, level)
            outfile.write('scope_id = %d,\n' % (self.scope_id,))
        if self.symbol_id is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            showIndent(outfile, level)
            outfile.write('symbol_id = "%s",\n' % (self.symbol_id,))
        super(SymbolReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SymbolReferenceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SymbolReferenceProperty=[\n')
        level += 1
        for SymbolReferenceProperty_ in self.SymbolReferenceProperty:
            showIndent(outfile, level)
            outfile.write('model_.SymbolReferenceProperty(\n')
            SymbolReferenceProperty_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scope_id', node)
        if value is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            try:
                self.scope_id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.scope_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('symbol_id', node)
        if value is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            self.symbol_id = value
        super(SymbolReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SymbolReferenceProperty':
            obj_ = SymbolReferencePropertyType.factory()
            obj_.build(child_)
            self.SymbolReferenceProperty.append(obj_)
        super(SymbolReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class SymbolReferenceType


class IndexTripletType(GeneratedsSuper):
    """index triplet allowing for simple indices using just "Index" but
    also for slicing using the second position "Bound" as well as
    "Stride". An empty expression indicates unknown information as
    would be the case when it is implicitly given by the context.
    The assumption in xaifBooster is that anything that is not a
    scalar dereference should have at least either Bound or Stride
    specified."""
    subclass = None
    superclass = None
    def __init__(self, Index=None, Bound=None, Stride=None):
        self.Index = Index
        self.Bound = Bound
        self.Stride = Stride
    def factory(*args_, **kwargs_):
        if IndexTripletType.subclass:
            return IndexTripletType.subclass(*args_, **kwargs_)
        else:
            return IndexTripletType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Index(self): return self.Index
    def set_Index(self, Index): self.Index = Index
    def get_Bound(self): return self.Bound
    def set_Bound(self, Bound): self.Bound = Bound
    def get_Stride(self): return self.Stride
    def set_Stride(self, Stride): self.Stride = Stride
    def export(self, outfile, level, namespace_='xaifnii:', name_='IndexTripletType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IndexTripletType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='IndexTripletType'):
        pass
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='IndexTripletType', fromsubclass_=False):
        if self.Index is not None:
            self.Index.export(outfile, level, namespace_, name_='Index')
        if self.Bound is not None:
            self.Bound.export(outfile, level, namespace_, name_='Bound')
        if self.Stride is not None:
            self.Stride.export(outfile, level, namespace_, name_='Stride')
    def hasContent_(self):
        if (
            self.Index is not None or
            self.Bound is not None or
            self.Stride is not None
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='IndexTripletType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Index is not None:
            showIndent(outfile, level)
            outfile.write('Index=model_.ExpressionType(\n')
            self.Index.exportLiteral(outfile, level, name_='Index')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Bound is not None:
            showIndent(outfile, level)
            outfile.write('Bound=model_.ExpressionType(\n')
            self.Bound.exportLiteral(outfile, level, name_='Bound')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Stride is not None:
            showIndent(outfile, level)
            outfile.write('Stride=model_.ExpressionType(\n')
            self.Stride.exportLiteral(outfile, level, name_='Stride')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Index':
            obj_ = ExpressionType.factory()
            obj_.build(child_)
            self.set_Index(obj_)
        elif nodeName_ == 'Bound':
            obj_ = ExpressionType.factory()
            obj_.build(child_)
            self.set_Bound(obj_)
        elif nodeName_ == 'Stride':
            obj_ = ExpressionType.factory()
            obj_.build(child_)
            self.set_Stride(obj_)
# end class IndexTripletType


class ArrayElementReferenceType(VertexType):
    """a reference to an array element or array slice using subscripts."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', IndexTriplet=None):
        super(ArrayElementReferenceType, self).__init__(annotation, vertex_id, )
        if IndexTriplet is None:
            self.IndexTriplet = []
        else:
            self.IndexTriplet = IndexTriplet
    def factory(*args_, **kwargs_):
        if ArrayElementReferenceType.subclass:
            return ArrayElementReferenceType.subclass(*args_, **kwargs_)
        else:
            return ArrayElementReferenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IndexTriplet(self): return self.IndexTriplet
    def set_IndexTriplet(self, IndexTriplet): self.IndexTriplet = IndexTriplet
    def add_IndexTriplet(self, value): self.IndexTriplet.append(value)
    def insert_IndexTriplet(self, index, value): self.IndexTriplet[index] = value
    def export(self, outfile, level, namespace_='xaifnii:', name_='ArrayElementReferenceType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ArrayElementReferenceType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ArrayElementReferenceType'):
        super(ArrayElementReferenceType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ArrayElementReferenceType')
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ArrayElementReferenceType', fromsubclass_=False):
        super(ArrayElementReferenceType, self).exportChildren(outfile, level, namespace_, name_, True)
        for IndexTriplet_ in self.IndexTriplet:
            IndexTriplet_.export(outfile, level, namespace_, name_='IndexTriplet')
    def hasContent_(self):
        if (
            self.IndexTriplet or
            super(ArrayElementReferenceType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ArrayElementReferenceType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ArrayElementReferenceType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ArrayElementReferenceType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('IndexTriplet=[\n')
        level += 1
        for IndexTriplet_ in self.IndexTriplet:
            showIndent(outfile, level)
            outfile.write('model_.IndexTripletType(\n')
            IndexTriplet_.exportLiteral(outfile, level, name_='IndexTripletType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ArrayElementReferenceType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IndexTriplet':
            obj_ = IndexTripletType.factory()
            obj_.build(child_)
            self.IndexTriplet.append(obj_)
        super(ArrayElementReferenceType, self).buildChildren(child_, node, nodeName_, True)
# end class ArrayElementReferenceType


class ConstantType(VertexType):
    """Constants in XAIF. For cases where the front-end distinguishes
    machine dependent types, e.g. sizes in bytes, the front-end can
    use the optional fe_type attribute. We do not assign any
    particular meaning to values other than the empty string which
    means unspecified."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', feType='', type_=None, value=None):
        super(ConstantType, self).__init__(annotation, vertex_id, )
        self.feType = _cast(None, feType)
        self.type_ = _cast(None, type_)
        self.value = _cast(None, value)
        pass
    def factory(*args_, **kwargs_):
        if ConstantType.subclass:
            return ConstantType.subclass(*args_, **kwargs_)
        else:
            return ConstantType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_feType(self): return self.feType
    def set_feType(self, feType): self.feType = feType
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def validate_ConstantTypeType(self, value):
        # Validate type ConstantTypeType, a restriction on xsd:string.
        pass
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def export(self, outfile, level, namespace_='xaifnii:', name_='ConstantType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ConstantType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ConstantType'):
        super(ConstantType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ConstantType')
        if self.feType is not None and 'feType' not in already_processed:
            already_processed.append('feType')
            outfile.write(' feType=%s' % (self.gds_format_string(quote_attrib(self.feType).encode(ExternalEncoding), input_name='feType'), ))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            outfile.write(' type=%s' % (quote_attrib(self.type_), ))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            outfile.write(' value=%s' % (self.gds_format_string(quote_attrib(self.value).encode(ExternalEncoding), input_name='value'), ))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ConstantType', fromsubclass_=False):
        super(ConstantType, self).exportChildren(outfile, level, namespace_, name_, True)
        pass
    def hasContent_(self):
        if (
            super(ConstantType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ConstantType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.feType is not None and 'feType' not in already_processed:
            already_processed.append('feType')
            showIndent(outfile, level)
            outfile.write('feType = "%s",\n' % (self.feType,))
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.append('type_')
            showIndent(outfile, level)
            outfile.write('type_ = "%s",\n' % (self.type_,))
        if self.value is not None and 'value' not in already_processed:
            already_processed.append('value')
            showIndent(outfile, level)
            outfile.write('value = "%s",\n' % (self.value,))
        super(ConstantType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ConstantType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('feType', node)
        if value is not None and 'feType' not in already_processed:
            already_processed.append('feType')
            self.feType = value
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.append('type')
            self.type_ = value
            self.validate_ConstantTypeType(self.type_)    # validate type ConstantTypeType
        value = find_attr_value_('value', node)
        if value is not None and 'value' not in already_processed:
            already_processed.append('value')
            self.value = value
        super(ConstantType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(ConstantType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class ConstantType


class FunctionCallType(VertexType):
    """Function calls are calls to subroutines (call graph vertices) that
    have a non-void return type. They are not intrinsics since
    derivative code must be generated by the AD tool. The are
    canonicalized by the front-end."""
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', scope_id=None, symbol_id=None, Argument=None):
        super(FunctionCallType, self).__init__(annotation, vertex_id, )
        self.scope_id = _cast(int, scope_id)
        self.symbol_id = _cast(None, symbol_id)
        if Argument is None:
            self.Argument = []
        else:
            self.Argument = Argument
    def factory(*args_, **kwargs_):
        if FunctionCallType.subclass:
            return FunctionCallType.subclass(*args_, **kwargs_)
        else:
            return FunctionCallType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Argument(self): return self.Argument
    def set_Argument(self, Argument): self.Argument = Argument
    def add_Argument(self, value): self.Argument.append(value)
    def insert_Argument(self, index, value): self.Argument[index] = value
    def get_scope_id(self): return self.scope_id
    def set_scope_id(self, scope_id): self.scope_id = scope_id
    def get_symbol_id(self): return self.symbol_id
    def set_symbol_id(self, symbol_id): self.symbol_id = symbol_id
    def export(self, outfile, level, namespace_='xaifnii:', name_='FunctionCallType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FunctionCallType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='FunctionCallType'):
        super(FunctionCallType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='FunctionCallType')
        if self.scope_id is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            outfile.write(' scope_id="%s"' % self.gds_format_integer(self.scope_id, input_name='scope_id'))
        if self.symbol_id is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            outfile.write(' symbol_id=%s' % (self.gds_format_string(quote_attrib(self.symbol_id).encode(ExternalEncoding), input_name='symbol_id'), ))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='FunctionCallType', fromsubclass_=False):
        super(FunctionCallType, self).exportChildren(outfile, level, namespace_, name_, True)
        for Argument_ in self.Argument:
            Argument_.export(outfile, level, namespace_, name_='Argument')
    def hasContent_(self):
        if (
            self.Argument or
            super(FunctionCallType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='FunctionCallType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.scope_id is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            showIndent(outfile, level)
            outfile.write('scope_id = %d,\n' % (self.scope_id,))
        if self.symbol_id is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            showIndent(outfile, level)
            outfile.write('symbol_id = "%s",\n' % (self.symbol_id,))
        super(FunctionCallType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(FunctionCallType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('Argument=[\n')
        level += 1
        for Argument_ in self.Argument:
            showIndent(outfile, level)
            outfile.write('model_.VariableReferenceType(\n')
            Argument_.exportLiteral(outfile, level, name_='VariableReferenceType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('scope_id', node)
        if value is not None and 'scope_id' not in already_processed:
            already_processed.append('scope_id')
            try:
                self.scope_id = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.scope_id <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('symbol_id', node)
        if value is not None and 'symbol_id' not in already_processed:
            already_processed.append('symbol_id')
            self.symbol_id = value
        super(FunctionCallType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Argument':
            class_obj_ = self.get_class_obj_(child_, VariableReferenceType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.Argument.append(obj_)
        super(FunctionCallType, self).buildChildren(child_, node, nodeName_, True)
# end class FunctionCallType


class PartialType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, dep=None, indep=None, partial=None):
        self.dep = _cast(int, dep)
        self.indep = _cast(int, indep)
        self.partial = _cast(int, partial)
        pass
    def factory(*args_, **kwargs_):
        if PartialType.subclass:
            return PartialType.subclass(*args_, **kwargs_)
        else:
            return PartialType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_dep(self): return self.dep
    def set_dep(self, dep): self.dep = dep
    def get_indep(self): return self.indep
    def set_indep(self, indep): self.indep = indep
    def get_partial(self): return self.partial
    def set_partial(self, partial): self.partial = partial
    def export(self, outfile, level, namespace_='xaifnii:', name_='PartialType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PartialType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='PartialType'):
        if self.dep is not None and 'dep' not in already_processed:
            already_processed.append('dep')
            outfile.write(' dep="%s"' % self.gds_format_integer(self.dep, input_name='dep'))
        if self.indep is not None and 'indep' not in already_processed:
            already_processed.append('indep')
            outfile.write(' indep="%s"' % self.gds_format_integer(self.indep, input_name='indep'))
        if self.partial is not None and 'partial' not in already_processed:
            already_processed.append('partial')
            outfile.write(' partial="%s"' % self.gds_format_integer(self.partial, input_name='partial'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='PartialType', fromsubclass_=False):
        pass
    def hasContent_(self):
        if (

            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='PartialType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.dep is not None and 'dep' not in already_processed:
            already_processed.append('dep')
            showIndent(outfile, level)
            outfile.write('dep = %d,\n' % (self.dep,))
        if self.indep is not None and 'indep' not in already_processed:
            already_processed.append('indep')
            showIndent(outfile, level)
            outfile.write('indep = %d,\n' % (self.indep,))
        if self.partial is not None and 'partial' not in already_processed:
            already_processed.append('partial')
            showIndent(outfile, level)
            outfile.write('partial = %d,\n' % (self.partial,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('dep', node)
        if value is not None and 'dep' not in already_processed:
            already_processed.append('dep')
            try:
                self.dep = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.dep <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('indep', node)
        if value is not None and 'indep' not in already_processed:
            already_processed.append('indep')
            try:
                self.indep = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.indep <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
        value = find_attr_value_('partial', node)
        if value is not None and 'partial' not in already_processed:
            already_processed.append('partial')
            try:
                self.partial = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.partial <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PartialType


class ScopeType(VertexType):
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', SymbolTable=None):
        super(ScopeType, self).__init__(annotation, vertex_id, )
        if SymbolTable is None:
            self.SymbolTable = []
        else:
            self.SymbolTable = SymbolTable
    def factory(*args_, **kwargs_):
        if ScopeType.subclass:
            return ScopeType.subclass(*args_, **kwargs_)
        else:
            return ScopeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SymbolTable(self): return self.SymbolTable
    def set_SymbolTable(self, SymbolTable): self.SymbolTable = SymbolTable
    def add_SymbolTable(self, value): self.SymbolTable.append(value)
    def insert_SymbolTable(self, index, value): self.SymbolTable[index] = value
    def export(self, outfile, level, namespace_='xaifnii:', name_='ScopeType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScopeType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ScopeType'):
        super(ScopeType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ScopeType')
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ScopeType', fromsubclass_=False):
        super(ScopeType, self).exportChildren(outfile, level, namespace_, name_, True)
        for SymbolTable_ in self.SymbolTable:
            SymbolTable_.export(outfile, level, namespace_, name_='SymbolTable')
    def hasContent_(self):
        if (
            self.SymbolTable or
            super(ScopeType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ScopeType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ScopeType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ScopeType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SymbolTable=[\n')
        level += 1
        for SymbolTable_ in self.SymbolTable:
            showIndent(outfile, level)
            outfile.write('model_.SymbolTable(\n')
            SymbolTable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ScopeType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SymbolTable':
            obj_ = SymbolTableType.factory()
            obj_.build(child_)
            self.SymbolTable.append(obj_)
        super(ScopeType, self).buildChildren(child_, node, nodeName_, True)
# end class ScopeType


class ScopeType1(VertexType):
    subclass = None
    superclass = VertexType
    def __init__(self, annotation='', vertex_id='1', SymbolTable=None):
        super(ScopeType1, self).__init__(annotation, vertex_id, )
        if SymbolTable is None:
            self.SymbolTable = []
        else:
            self.SymbolTable = SymbolTable
    def factory(*args_, **kwargs_):
        if ScopeType1.subclass:
            return ScopeType1.subclass(*args_, **kwargs_)
        else:
            return ScopeType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SymbolTable(self): return self.SymbolTable
    def set_SymbolTable(self, SymbolTable): self.SymbolTable = SymbolTable
    def add_SymbolTable(self, value): self.SymbolTable.append(value)
    def insert_SymbolTable(self, index, value): self.SymbolTable[index] = value
    def export(self, outfile, level, namespace_='xaifnii:', name_='ScopeType1', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ScopeType1')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='ScopeType1'):
        super(ScopeType1, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ScopeType1')
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='ScopeType1', fromsubclass_=False):
        super(ScopeType1, self).exportChildren(outfile, level, namespace_, name_, True)
        for SymbolTable_ in self.SymbolTable:
            SymbolTable_.export(outfile, level, namespace_, name_='SymbolTable')
    def hasContent_(self):
        if (
            self.SymbolTable or
            super(ScopeType1, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='ScopeType1'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ScopeType1, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ScopeType1, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('SymbolTable=[\n')
        level += 1
        for SymbolTable_ in self.SymbolTable:
            showIndent(outfile, level)
            outfile.write('model_.SymbolTable(\n')
            SymbolTable_.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(ScopeType1, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SymbolTable':
            obj_ = SymbolTableType.factory()
            obj_.build(child_)
            self.SymbolTable.append(obj_)
        super(ScopeType1, self).buildChildren(child_, node, nodeName_, True)
# end class ScopeType1


class AssignmentLHSType(VariableReferenceType):
    """An attribute specifying whether a variable reference occuring on the
    left-hand side of an assigment is live at the end of the basic
    block or at the next Marker, whichever is closest."""
    subclass = None
    superclass = VariableReferenceType
    def __init__(self, annotation='', vertex_id='1', active='undefined', alias=0, du_ud=0, constant=False, deriv=False, VariableReferenceVertex=None, VariableReferenceEdge=None, live=True):
        super(AssignmentLHSType, self).__init__(annotation, vertex_id, active, alias, du_ud, constant, deriv, VariableReferenceVertex, VariableReferenceEdge, )
        self.live = _cast(bool, live)
        pass
    def factory(*args_, **kwargs_):
        if AssignmentLHSType.subclass:
            return AssignmentLHSType.subclass(*args_, **kwargs_)
        else:
            return AssignmentLHSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_live(self): return self.live
    def set_live(self, live): self.live = live
    def export(self, outfile, level, namespace_='xaifnii:', name_='AssignmentLHSType', namespacedef_=''):
        showIndent(outfile, level)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = []
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AssignmentLHSType')
        if self.hasContent_():
            outfile.write('>\n')
            self.exportChildren(outfile, level + 1, namespace_, name_)
            showIndent(outfile, level)
            outfile.write('</%s%s>\n' % (namespace_, name_))
        else:
            outfile.write('/>\n')
    def exportAttributes(self, outfile, level, already_processed, namespace_='xaifnii:', name_='AssignmentLHSType'):
        super(AssignmentLHSType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='AssignmentLHSType')
        if self.live is not None and 'live' not in already_processed:
            already_processed.append('live')
            outfile.write(' live="%s"' % self.gds_format_boolean(self.gds_str_lower(str(self.live)), input_name='live'))
    def exportChildren(self, outfile, level, namespace_='xaifnii:', name_='AssignmentLHSType', fromsubclass_=False):
        super(AssignmentLHSType, self).exportChildren(outfile, level, namespace_, name_, True)
    def hasContent_(self):
        if (
            super(AssignmentLHSType, self).hasContent_()
            ):
            return True
        else:
            return False
    def exportLiteral(self, outfile, level, name_='AssignmentLHSType'):
        level += 1
        self.exportLiteralAttributes(outfile, level, [], name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.live is not None and 'live' not in already_processed:
            already_processed.append('live')
            showIndent(outfile, level)
            outfile.write('live = %s,\n' % (self.live,))
        super(AssignmentLHSType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(AssignmentLHSType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        self.buildAttributes(node, node.attrib, [])
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('live', node)
        if value is not None and 'live' not in already_processed:
            already_processed.append('live')
            if value in ('true', '1'):
                self.live = True
            elif value in ('false', '0'):
                self.live = False
            else:
                raise_parse_error(node, 'Bad boolean attribute')
        super(AssignmentLHSType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(AssignmentLHSType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class AssignmentLHSType


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""

def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'NonInlinableIntrinsicBaseType'
        rootClass = NonInlinableIntrinsicBaseType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_=rootTag, 
        namespacedef_='')
    return rootObj


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'NonInlinableIntrinsicBaseType'
        rootClass = NonInlinableIntrinsicBaseType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(sys.stdout, 0, name_="NonInlinableIntrinsicBaseType",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'NonInlinableIntrinsicBaseType'
        rootClass = NonInlinableIntrinsicBaseType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from xaif_noninlinable_intrinsics import *\n\n')
    sys.stdout.write('import xaif_noninlinable_intrinsics as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "AliasRangeType",
    "AliasSetMapType",
    "AliasSetType",
    "ArgumentListType",
    "ArgumentSymbolReferenceType",
    "ArrayElementReferenceType",
    "AssignmentBaseType",
    "AssignmentLHSType",
    "AssignmentType",
    "BasicBlockAssignmentType",
    "BasicBlockElementType",
    "BasicBlockType",
    "BooleanOperationType",
    "BranchType",
    "CallGraphType",
    "ConstantType",
    "ControlFlowEdgeType",
    "ControlFlowGraphType",
    "DimensionBoundsType",
    "DirectActionType",
    "EdgeType",
    "EndBranchType",
    "EndLoopType",
    "EntryType",
    "ExitType",
    "ExplicitJacobianType",
    "ExpressionEdgeType",
    "ExpressionType",
    "ForLoopType",
    "FrontEndAnnotationType",
    "FunctionCallType",
    "GotoType",
    "IfType",
    "IndexTripletType",
    "IntrinsicType",
    "LabelType",
    "MarkerType",
    "NonInlinableIntrinsicBaseType",
    "NonInlinableIntrinsicDefinitions",
    "PartialType",
    "PostLoopType",
    "PreLoopType",
    "ScopeHierarchyType",
    "ScopeType",
    "ScopeType1",
    "SideEffectListType",
    "StatementIdRefType",
    "StmtIdSetMapType",
    "StmtIdSetWithKeyType",
    "SubroutineArgumentType",
    "SubroutineCallType",
    "SymbolReferencePropertyType",
    "SymbolReferenceType",
    "SymbolTableType",
    "SymbolType",
    "VariableReferenceType",
    "VertexType"
    ]
